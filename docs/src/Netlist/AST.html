<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.Netlist.AST API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.Netlist.AST</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import json
import base64
import pickle
import networkx as nx


# from src.utils import *
import src.utils as utils
import src.yosys as yosys
import src.Parser.conv as conv
from src.Verification.verification import *





class module:
    def __init__(self):
        &#34;&#34;&#34;
        Initialize the module object.
        &#34;&#34;&#34;
        self.change_flag=1
        self.org_code_verilog = None
        self.org_code_bench = None
        self.gate_level_verilog = None
        self.module_name = None
        self.gates = None
        self.FF_tech=None
        self.io = None
        self.circuitgraph=None
        self.module_LLverilog=&#34;&#34;
        self.lockingdata={&#34;wires&#34;:[],&#34;gates&#34;:[],&#34;inputs&#34;:[]}
        self.bitkey=&#34;&#34;
        # self.module_LLverilog=None
        # self.module_LLcircuitgraph=None
    
    def gen_graph(self):
        &#34;&#34;&#34;
        Generate the circuit graph.
        &#34;&#34;&#34;
        self.circuitgraph = nx.DiGraph()
        for logic_gate in self.gates:
            for init_name in self.gates[logic_gate]:
                node=self.gates[logic_gate][init_name]
                tmpi=self.gates[logic_gate]
                node_input=node[&#34;inputs&#34;]
                node_output=node[&#34;outputs&#34;]
                node_name=init_name
                port=utils.check_port(node_output)
                self.circuitgraph.add_node(node_name, type=&#34;gate&#34;,logic=logic_gate)

                if(port in self.io[&#34;outputs&#34;]):
                    self.circuitgraph.add_node(node_output, type=&#34;output&#34;)
                    self.circuitgraph.add_edge(node_name, node_output)
                elif(port in self.io[&#34;wires&#34;]):
                    self.circuitgraph.add_node(node_output, type=&#34;wire&#34;)
                    self.circuitgraph.add_edge(node_name, node_output)
                else:
                    print(self.module_name)
                    print(port,node_output)
                    raise Exception(&#34;NODE NOT FOUND&#34;)


                for i in node_input:
                    def tmp():
                        if(&#34;XNOR_117153_&#34; in init_name):
                            print(&#34;HERE212 &#34;,i,node_input,node_name)
                    tmptxt=utils.check_port(i)

                    if(tmptxt in self.io[&#34;inputs&#34;]):
                        self.circuitgraph.add_node(i, type=&#34;input&#34;,port=tmptxt)
                        self.circuitgraph.add_edge(i,node_name)
                    elif(tmptxt in self.io[&#34;outputs&#34;]):
                        self.circuitgraph.add_node(i, type=&#34;output&#34;,port=tmptxt)
                        self.circuitgraph.add_edge(i,node_name)
                        # tmp()
                        # print(i)
                    elif(tmptxt in self.io[&#34;wires&#34;]):
                        self.circuitgraph.add_node(i, type=&#34;wire&#34;,port=tmptxt)
                        self.circuitgraph.add_edge(i,node_name)
                    elif(i in self.io[&#34;wires&#34;]):
                        self.circuitgraph.add_node(i, type=&#34;wire&#34;,port=tmptxt)
                        self.circuitgraph.add_edge(i,node_name)
                    elif(&#34;1&#39;&#34; in i):
                        self.circuitgraph.add_node(i, type=&#34;bit&#34;,value=i)
                        self.circuitgraph.add_edge(i,node_name)
                    else:
                        print(&#34;HERE&#34;)
                        print(self.module_name,&#34; ==&gt;&gt; &#34;,tmptxt,i)
                        raise Exception(&#34;NODE NOT FOUND&#34;)

        # print(&#34;HERE&#34;,self.FF_tech)
        for FF in self.FF_tech:
            for init_name in self.FF_tech[FF]:
                tmpi=self.FF_tech[FF]
                node=tmpi[init_name]
                node_input=node[&#34;inputs&#34;]
                node_output=node[&#34;outputs&#34;]
                node_name=init_name
                
                rst=node.get(&#34;reset&#34;)
                clk=node.get(&#34;clock&#34;)
                self.circuitgraph.add_node(node_name, type=FF,clock=clk,reset=rst)
                # print(init_name)
                



                self.circuitgraph.add_node(clk, type=&#34;input&#34;)
                self.circuitgraph.add_edge(clk, node_name)

                if(rst!=None):
                    self.circuitgraph.add_node(rst, type=&#34;input&#34;)
                    self.circuitgraph.add_edge(rst, node_name)

                port=utils.check_port(node_output)
                if(port in self.io[&#34;outputs&#34;]):
                    self.circuitgraph.add_node(node_output, type=&#34;output&#34;,port=port)
                    self.circuitgraph.add_edge(node_name, node_output)
                elif(port in self.io[&#34;wires&#34;]):
                    self.circuitgraph.add_node(node_output, type=&#34;wire&#34;,port=port)
                    self.circuitgraph.add_edge(node_name, node_output)
                else:
                    print(self.module_name)
                    print(port,node_output)
                    raise Exception(&#34;NODE NOT FOUND&#34;)
                

                tmptxt=utils.check_port(node_input)
                if(tmptxt in self.io[&#34;inputs&#34;]):
                    self.circuitgraph.add_node(node_input, type=&#34;input&#34;,port=tmptxt)
                    self.circuitgraph.add_edge(node_input,node_name)
                elif(tmptxt in self.io[&#34;outputs&#34;]):
                    self.circuitgraph.add_node(node_input, type=&#34;output&#34;,port=tmptxt)
                    self.circuitgraph.add_edge(node_name,node_input)
                elif(tmptxt in self.io[&#34;wires&#34;]):
                    self.circuitgraph.add_node(node_input, type=&#34;wire&#34;,port=tmptxt)
                    self.circuitgraph.add_edge(node_input,node_name)
                elif(node_input in self.io[&#34;wires&#34;]):
                    self.circuitgraph.add_node(node_input, type=&#34;wire&#34;,port=node_input)
                    self.circuitgraph.add_edge(node_input,node_name)
                elif(&#34;1&#39;h&#34; in node_input):
                    self.circuitgraph.add_node(node_input, type=&#34;bit&#34;,value=int(node_input[-1]))
                    self.circuitgraph.add_edge(node_input,node_name)
                else:
                    print(self.module_name)
                    print(tmptxt,i)
                    raise Exception(&#34;NODE NOT FOUND&#34;)

        self.circuitgraph.add_node(&#34;module#&#34;+self.module_name, type=&#34;module&#34;)
        for i in self.io[&#34;outputs&#34;]:
            tmpi=self.io[&#34;outputs&#34;][i]
            if(tmpi[&#39;bits&#39;]==1):
                self.circuitgraph.add_edge(i,&#34;module#&#34;+self.module_name)
            else:
                for k in range(tmpi[&#39;startbit&#39;],tmpi[&#34;endbit&#34;]+1):
                    self.circuitgraph.add_edge(i+f&#34;[{k}]&#34;,&#34;module#&#34;+self.module_name)

        for i in self.io[&#34;inputs&#34;]:
            tmpi=self.io[&#34;inputs&#34;][i]
            if(tmpi[&#39;bits&#39;]==1):
                self.circuitgraph.add_edge(&#34;module#&#34;+self.module_name,i)
            else:
                for k in range(tmpi[&#39;startbit&#39;],tmpi[&#34;endbit&#34;]+1):
                    self.circuitgraph.add_edge(&#34;module#&#34;+self.module_name,i+f&#34;[{k}]&#34;)
        self.change_flag=0

    
    def bin_graph(self):
        &#34;&#34;&#34;
        Encode the circuit graph to a binary string using pickle and encode the binary string to a base64 string.
        &#34;&#34;&#34;
        self.base64_data = base64.b64encode(pickle.dumps(self.circuitgraph)).decode(&#39;utf-8&#39;)

    def nodeio(self,Node)-&gt;None:
        &#34;&#34;&#34;
        Print the outputs and inputs of a node in the circuit graph.
        
        Args:
            Node (str): The name of the node.
        &#34;&#34;&#34;
        print(&#34;Node outputs = &#34;,list(self.circuitgraph.successors(Node))) 
        print(&#34;Node inputs = &#34;,list(self.circuitgraph.predecessors(Node)))    
    
    def save_graph(self,svg=False):
        &#34;&#34;&#34;
        Save the circuit graph as an SVG image.
        
        Args:
            svg (bool): Whether to save the graph as an SVG image (default: False).
        &#34;&#34;&#34;
        utils.save_graph(self.circuitgraph,svg)

    # def gen_org_verilog(self):
    #     self.gate_level_verilog=f&#34;module {self.module_name}({self.io[&#39;input_ports&#39;]}{self.io[&#39;output_ports&#39;][:-1]});\n&#34;
    #     self.gate_level_verilog+=utils.node_to_txt(self.io[&#39;inputs&#39;],mode=&#34;input&#34;)
    #     self.gate_level_verilog+=utils.node_to_txt(self.io[&#39;outputs&#39;],mode=&#34;output&#34;)
    #     self.gate_level_verilog+=utils.node_to_txt(self.io[&#39;wires&#39;],mode=&#34;wire&#34;)
    #     self.gate_level_verilog+=utils.gates_to_txt(self.gates)
    #     self.gate_level_verilog+=utils.FF_to_txt(self.FF_tech)
    #     # self.module_LLverilog+=module_to_txt(self.linkages)
    #     for j in self.linkages:
    #         tmpj=self.linkages[j]
    #         self.gate_level_verilog+=f&#34;{tmpj[&#39;module_name&#39;]} {j}({tmpj[&#39;port&#39;]}); \n&#34;
    #     self.gate_level_verilog+=&#34;endmodule\n&#34;


    def gen_LL_verilog(self):
        &#34;&#34;&#34;
        Generate the LL verilog code for the module.
        &#34;&#34;&#34;
        self.module_LLverilog=f&#34;module {self.module_name}({self.io[&#39;input_ports&#39;]}{self.io[&#39;output_ports&#39;][:-1]});\n&#34;
        self.module_LLverilog+=utils.node_to_txt(self.io[&#39;inputs&#39;],mode=&#34;input&#34;)
        self.module_LLverilog+=utils.node_to_txt(self.io[&#39;outputs&#39;],mode=&#34;output&#34;)
        self.module_LLverilog+=utils.node_to_txt(self.io[&#39;wires&#39;],mode=&#34;wire&#34;)
        self.module_LLverilog+=utils.gates_to_txt(self.gates)
        self.module_LLverilog+=utils.FF_to_txt(self.FF_tech)
        # self.module_LLverilog+=module_to_txt(self.linkages)
        for j in self.linkages:
            tmpj=self.linkages[j]
            self.module_LLverilog+=f&#34;{tmpj[&#39;module_name&#39;]} {j}({tmpj[&#39;port&#39;]}); \n&#34;
        self.module_LLverilog+=&#34;endmodule\n&#34;
        # if(self.postSAT_modules!={}):
        #     self.module_LLverilog+=module_to_txt(self.postSAT_modules)


class AST:
    &#34;&#34;&#34;

    
    &#34;&#34;&#34;
    def __init__(self,
                 file_path,
                 top=None,
                 rw = &#39;w&#39;,
                 flag = &#39;v&#39;,
                 filename=None,
                 vlibpath=&#34;vlib/mycells.v&#34;,
                 sub_modules=None
                 ):
        self.LLverilog = &#34;&#34;
        self.postsat_lib=&#34;&#34;
        if(filename==None):
            self.filename=top
            self.filepath=&#34;./output_files/{}.json&#34;.format(top)
        else:
            self.filename=filename
            self.filepath=&#34;./output_files/{}.json&#34;.format(self.filename)
        if rw == &#39;r&#39;:
            self.read_LLFile(file_path)
        elif rw == &#39;w&#39;:
            if flag == &#39;v&#39;:
                self.verilog = open(file_path).read()
                
                if(sub_modules!=None):
                    if(type(sub_modules)==list):
                        for files in sub_modules:
                            self.verilog+=open(files).read()
                    else:
                        self.verilog+=open(sub_modules).read()
                
                tmp_file_path=f&#34;./tmp/tmp_verilog_{top}.v&#34;
                with open(tmp_file_path,&#34;w&#34;) as f:
                    f.write(self.verilog)
                # self.verilog=format_verilog_org(self.verilog)
                print(&#34;Verifiying Input Verilog File&#34;)
                yosys.verify_verilog(tmp_file_path,top)
                print(&#34;Input Verilog File Verified Without Issue&#34;)
                os.remove(tmp_file_path)
                
            elif flag == &#39;b&#39;:
                self.bench = open(file_path).read()
                self.verilog = conv.bench_to_verilog(self.bench)
            else:
                Exception(&#34;Enter either &#39;v&#39; (for verilog) or &#39;b&#39; (for bench)&#34;)
            
            self.synthesized_verilog = None
            self.extracted_modules = None
            self.top_module = module()
            self.modules = {}
            # self.linkages={}
            self.top_module_name=top
            self.gate_lib=open(vlibpath).read()
            self.gen_LLFile()
            self.writeLLFile() 
        else:
            Exception(&#34;Enter either &#39;r&#39; (for read) or &#39;w&#39; (for write)&#34;)
        
    def gen_LLFile(self):
        print(&#34;Generating Logic Locking AST File&#34;)
        self.synthesized_verilog = yosys.synthesize_verilog(self.verilog,top=self.top_module_name)#,flag=&#34;dont_flatten&#34;
        self.gate_level_flattened=self.synthesized_verilog
        # self.gate_level_flattened = synthesize_verilog(self.verilog,top=self.top_module_name)
        self.flatten_bench = conv.verilog_to_bench(self.gate_level_flattened)

        self.modules_techmap = utils.module_extraction(self.synthesized_verilog)
        self.extracted_modules = utils.module_extraction(self.synthesized_verilog)
        self.no_of_modules = len(self.extracted_modules)

        self.sub_modules_data()
        self.gen_graph_links()

        print(&#34;Done Generating Logic Locking AST File&#34;)
            # self.modules[i].bin_graph()
        
        # self.gen_module_connections()        
        
    def sub_modules_data(self):
        for key in self.extracted_modules:
            self.modules[key]=module()
            self.modules[key].module_name = key
            self.modules[key].org_code_verilog = self.extracted_modules[key]
            self.modules[key].gate_level_verilog = self.modules_techmap[key]
            self.modules[key].gates,self.modules[key].linkages,tmp = utils.gates_module_extraction(self.modules[key].gate_level_verilog)            
            self.modules[key].FF_tech,self.modules[key].Clock_pins,self.modules[key].Reset_pins=tmp


            # print(self.modules[key].linkages.keys())

            inputs, input_ports = extract_io_v(self.modules[key].org_code_verilog)
            outputs, output_ports = extract_io_v(self.modules[key].org_code_verilog, &#34;output&#34;)
            wire, _ = extract_io_v(self.modules[key].gate_level_verilog, &#34;wire&#34;)
            wire={key:wire[key]  for key in get_difference_abs(wire.keys(),inputs.keys(),outputs.keys())}


            for i in self.modules[key].Clock_pins:
                if((&#34;1&#39;&#34; in i) or (i not in inputs.keys())):
                    self.modules[key].Clock_pins.remove(i)
            # print(&#34;N4944&#34; in  wire.keys())
            # print(get_diference(wire.keys(),outputs.keys()))
            # print(&#34;HERE&#34;,wire[&#34;cpuregs[5]&#34;])
            
            # print(&#34;N1947&#34; in outputs.keys())
            # print(self.modules[key].gates)
            self.modules[key].io = dict({&#34;Clock_pins&#34;:self.modules[key].Clock_pins,&#34;Reset_pins&#34;:self.modules[key].Reset_pins,&#39;wires&#39;:wire,&#39;inputs&#39;:inputs,&#39;outputs&#39;:outputs,&#39;input_ports&#39;:input_ports,&#39;output_ports&#39;:output_ports})
            self.modules[key].gen_graph()
        self.top_module=self.modules[self.top_module_name]
            
    def writeLLFile(self):
        print(&#34;Writing LL file&#34;)
        self.update_LLverilog()
        ast_dict = dict({&#34;orginal_code&#34; : self.verilog, &#34;gate_lib&#34;:self.gate_lib,&#34;gate_level_flattened&#34; : self.gate_level_flattened,&#34;Bench_format_flattened&#34; : self.flatten_bench, &#34;gate_level_not_flattened&#34; : self.synthesized_verilog, &#34;top_module_name&#34; : self.top_module_name,&#34;Total_number_of_modules&#34;:self.no_of_modules,&#34;LL_gatelevel_verilog&#34;:self.LLverilog,&#34;bitkey&#34;:self.top_module.bitkey})
        # top_dict = dict({&#34;Verilog&#34;: self.top_module.org_code_verilog, &#34;Synthesized_verilog&#34; : self.top_module.gate_level_verilog, &#34;Total_number_of_modules&#34;:self.no_of_modules, &#34;io&#34;:self.top_module.io, &#34;gates&#34;: self.top_module.gates, &#34;links&#34; : self.top_module.linkages, &#34;DiGraph&#34;:self.top_module.base64_data})
        # top_dict = dict({&#34;Total_number_of_modules&#34;:self.no_of_modules, &#34;io&#34;:self.top_module.io, &#34;gates&#34;: self.top_module.gates, &#34;links&#34; : self.top_module.linkages, &#34;DiGraph&#34;:self.top_module.base64_data})

        sub_dict = {}
        for key in list(self.modules.keys()):
            self.modules[key].bin_graph()
            sub_dict[key] = dict({&#34;Verilog&#34;: self.modules[key].org_code_verilog, &#34;Synthesized_verilog&#34; : self.modules[key].gate_level_verilog,&#34;lockingdata&#34;:self.modules[key].lockingdata,&#34;DiGraph&#34;:self.modules[key].base64_data, &#34;io&#34;:self.modules[key].io, &#34;gates&#34;: self.modules[key].gates,&#34;FF&#34;:self.modules[key].FF_tech,&#34;links&#34; : self.modules[key].linkages})#&#34;postSAT_modules&#34; : self.modules[key].postSAT_modules, &#34;links&#34; : self.modules[key].linkages


        ast = dict({&#34;AST&#34;:ast_dict,&#34;modules&#34;: sub_dict})

        json_file = json.dumps(ast, indent = 4)
        with open(self.filepath, &#34;w&#34;) as verilog_ast:
            verilog_ast.write(json_file)
        print(&#34;Done Writing LL file&#34;)

    def gen_graph_links(self):
        def process_node(R,module):
            if(&#34;:&#34; in R):
                node,startbit,endbit=re.findall(&#34;(.*)\[(\d+):?(\d*)\]&#34;,R)[0]
                endbit,startbit=int(endbit),int(startbit)
            elif(&#34;[&#34; in R):
                node,bit=re.findall(&#34;(.*)\[(\d+)\]&#34;,R)[0]
                endbit,startbit=int(bit),int(bit)
            else:
                node=R
                endbit,startbit=None,None

            if(node in module.io[&#39;inputs&#39;]):
                Node=module.io[&#39;inputs&#39;][node]
                type=&#39;input&#39;
            elif(node in module.io[&#39;outputs&#39;]):
                Node=module.io[&#39;outputs&#39;][node]
                type=&#39;output&#39;
            elif(node in module.io[&#39;wires&#39;]):
                Node=module.io[&#39;wires&#39;][node]
                type=&#39;wire&#39;
            else:
                print(module.module_name,R)
                raise Exception(&#34;NODE NOT FOUND&#34;)

            if(endbit==None):
                # print(Node)
                if(Node[&#39;bits&#39;]==1):
                    endbit=0
                    startbit=0
                else:
                    endbit=Node[&#39;endbit&#39;]
                    startbit=Node[&#39;startbit&#39;]
                    
            return node,type,endbit,startbit

        def process_links(module):
            links=module.linkages
            for ii in links:
                i=links[ii]
                module_node_name=&#34;module#&#34;+ii
                module.circuitgraph.add_node(module_node_name, type=&#34;module&#34;,module_name=i[&#39;module_name&#39;],init_name=ii)

                for x in i[&#39;links&#39;]:
                    L,R,T=x
                    node,type,endbit,startbit=process_node(R,module)
                    if(T==&#34;I&#34;):
                        if(endbit==0):
                            module.circuitgraph.add_node(node,type=type,port=node)
                            module.circuitgraph.add_edge(node,module_node_name)
                        else:
                            # print(R,node,module_node_name)
                            for k in range(startbit,endbit+1):
                                module.circuitgraph.add_node(node+f&#34;[{k}]&#34;,type=type,port=node)
                                module.circuitgraph.add_edge(node+f&#34;[{k}]&#34;,module_node_name)
                    elif(T==&#34;O&#34;):
                        if(endbit==0):
                            module.circuitgraph.add_node(node,type=type,port=node)
                            module.circuitgraph.add_edge(module_node_name,node)
                        else:
                            for k in range(startbit,endbit+1):
                                module.circuitgraph.add_node(node+f&#34;[{k}]&#34;,type=type,port=node)
                                module.circuitgraph.add_edge(module_node_name,node+f&#34;[{k}]&#34;)
                    else:
                        raise Exception(&#34;NODE NOT FOUND&#34;)
   
                # if(L in self.modules[i[&#39;module_name&#39;]].io[&#39;inputs&#39;]):
                #     for k in range(startbit,endbit+1):
                #         module.circuitgraph.add_node(node+f&#34;[{k}]&#34;,type=type,port=node)
                #         module.circuitgraph.add_edge(node+f&#34;[{k}]&#34;,module_node_name)
                # elif(L in self.modules[i[&#39;module_name&#39;]].io[&#39;outputs&#39;]):
                #     for k in range(startbit,endbit+1):
                #         module.circuitgraph.add_node(node+f&#34;[{k}]&#34;,type=type,port=node)
                #         module.circuitgraph.add_edge(module_node_name,node+f&#34;[{k}]&#34;)
                # else:
                #     raise Exception(&#34;NODE NOT FOUND&#34;)
        
        for i in self.modules:
            process_links(self.modules[i])

    def read_LLFile(self, file_path):
        print(&#34;Reading LL file&#34;)
        print(&#34;\t Loading json file&#34;)
        with open(file_path) as json_file:
            verilog_ast = json.load(json_file)
        
        print(&#34;\t Done Loading json file&#34;)

        print(&#34;\t Loading Top module in AST&#34;)
        self.top_module = module()
        self.modules = {}
        self.verilog =  verilog_ast[&#34;AST&#34;][&#34;orginal_code&#34;]
        self.gate_level_flattened = verilog_ast[&#34;AST&#34;][&#34;gate_level_flattened&#34;]
        self.synthesized_verilog = verilog_ast[&#34;AST&#34;][&#34;gate_level_not_flattened&#34;]
        self.top_module_name  = verilog_ast[&#34;AST&#34;][&#34;top_module_name&#34;]
        self.no_of_modules = verilog_ast[&#34;AST&#34;][&#34;Total_number_of_modules&#34;]
        self.flatten_bench=verilog_ast[&#34;AST&#34;][&#34;Bench_format_flattened&#34;]
        self.gate_lib=verilog_ast[&#34;AST&#34;][&#34;gate_lib&#34;]
        # self.linkages=verilog_ast[&#34;linkages&#34;]
        print(f&#34;\t Done Loading Top module {self.top_module_name} in AST&#34;)

        keys = list((verilog_ast[&#34;modules&#34;]).keys())
        print(&#34;\t Loading module data in AST&#34;)
        for i in keys:
            print(f&#34;\t\t Loading module {i} in AST&#34;)
            self.modules[i]=module()
            self.modules[i].module_name = i
            self.modules[i].org_code_verilog = verilog_ast[&#34;modules&#34;][i][&#34;Verilog&#34;]
            self.modules[i].gate_level_verilog = verilog_ast[&#34;modules&#34;][i][&#34;Synthesized_verilog&#34;]
            self.modules[i].io = verilog_ast[&#34;modules&#34;][i][&#34;io&#34;]
            self.modules[i].gates = verilog_ast[&#34;modules&#34;][i][&#34;gates&#34;]
            self.modules[i].linkages = verilog_ast[&#34;modules&#34;][i][&#34;links&#34;]
            self.modules[i].FF_tech=verilog_ast[&#34;modules&#34;][i][&#34;FF&#34;]
            # self.modules[i].postSAT_modules = verilog_ast[&#34;modules&#34;][i][&#34;postSAT_modules&#34;]
            self.modules[i].lockingdata=verilog_ast[&#34;modules&#34;][i][&#34;lockingdata&#34;]
            #Decode the base64 string back to binary
            # Decode the binary string back to a graph object
            self.modules[i].base64_data = verilog_ast[&#34;modules&#34;][i][&#34;DiGraph&#34;]
            self.modules[i].circuitgraph = pickle.loads(base64.b64decode(self.modules[i].base64_data.encode(&#39;utf-8&#39;)))
            print(f&#34;\t\t Done Loading module {i} in AST&#34;)
        print(&#34;\t Done Loading module data in AST&#34;)
        self.top_module=self.modules[self.top_module_name]
        self.top_module.bitkey=verilog_ast[&#34;AST&#34;][&#34;bitkey&#34;]
        print(&#34;Done Reading LL file&#34;)
    
    # def gen_module_connections(self):
    #     self.module_connections = nx.DiGraph()
    #     for i in self.modules:
    #         tmpi=self.modules[i]
    #         for jj in tmpi.linkages:
    #             j=tmpi.linkages[jj]
    #             module_name = j[&#39;module_name&#39;]
    #             init_name = jj  
    #             # Check if an edge already exists in the graph
    #             if self.module_connections.has_edge(i, module_name):
    #                 # If an edge already exists, update its attributes without overwriting
    #                 # existing ones
    #                 tmp=[self.module_connections[i][module_name][&#39;init_name&#39;]]
    #                 tmp.append(init_name)
    #                 # print(tmp)
    #                 self.module_connections[i][module_name].update({&#39;init_name&#39;: tmp})
    #             else:
    #                 # If no edge exists, add a new edge with the specified attributes
    #                 self.module_connections.add_edge(i, module_name, init_name=init_name) 

    
    # def save_module_connections(self):
    #     save_graph(self.module_connections)
    

    # def update_org_verilog(self):
    #     self.gate_level_flattened=&#34;&#34;
    #     for i in self.modules:
    #         self.modules[i].gen_org_verilog()
    #         self.LLverilog=&#34;&#34;
    #         self.gate_level_flattened+=self.top_module.gate_level_verilog+&#34;\n&#34;
    #         for i in self.modules:
    #             if(i!=self.top_module_name):
    #                 self.gate_level_flattened+=self.modules[i].gate_level_verilog+&#34;\n&#34;


    def update_LLverilog(self):
        for i in self.modules:
            if(self.modules[i].change_flag==1):
                self.modules[i].gen_graph()
        self.gen_graph_links()
        
        
        
        if(&#34;lockingkeyinput&#34; in self.top_module.io[&#34;inputs&#34;]):
            print(&#34;\t Updating Logic Locked Verilog Code&#34;)
            for i in self.modules:
                self.modules[i].gen_LL_verilog()
            self.LLverilog=&#34;&#34;
            self.LLverilog+=self.top_module.module_LLverilog+&#34;\n&#34;
            for i in self.modules:
                if(i!=self.top_module_name):
                    self.LLverilog+=self.modules[i].module_LLverilog+&#34;\n&#34;
            
            self.postsat_lib=&#34;&#34;
            for i in self.modules:
                tmpi=self.modules[i]
                for j in tmpi.linkages:
                    self.postsat_lib+=&#34;\n&#34;+tmpi.linkages[j][&#39;code&#39;]+&#34;\n&#34;
            print(&#34;\t Done Updating Logic Locked Verilog Code&#34;)
        else:
            print(&#34;\t Netlist Not Locked, No Update to Peform&#34;)


    def write_Verilog_File(self,file=&#34;LL&#34;,file_name=&#34;&#34;,output_dir=r&#34;./tmp/&#34;):
        print(&#34;Generating Output Verilog File&#34;)
        if(file==&#34;LL&#34;):
            cir=self.LLverilog+&#34;\n\n\n&#34;+self.postsat_lib+&#34;\n\n\n&#34;+self.gate_lib
            cir=re.sub(r&#34;\n&#34;,r&#34;\n &#34;,cir)
            cir=re.sub(r&#34; module&#34;,r&#34;module&#34;,cir)
            cir=re.sub(r&#34; endmodule&#34;,r&#34;endmodule&#34;,cir)

            bits=self.top_module.io[&#34;inputs&#34;][&#34;lockingkeyinput&#34;][&#39;bits&#39;]

            cir=yosys.synthesize_verilog_flatten_gate(verilog=cir,top=self.top_module_name)
            cir=f&#34;// lockingkey = {bits}&#39;b{self.top_module.bitkey} \n&#34;+cir
        elif(file==&#34;org&#34;):
            cir=self.gate_level_flattened + &#34;\n\n\n&#34; + self.gate_lib
            cir=re.sub(r&#34;\n&#34;,r&#34;\n &#34;,cir)
            cir=re.sub(r&#34; module&#34;,r&#34;module&#34;,cir)
            cir=re.sub(r&#34; endmodule&#34;,r&#34;endmodule&#34;,cir)

            cir=yosys.synthesize_verilog_flatten_gate(verilog=cir,top=self.top_module_name)
        else:
            raise Exception(f&#34;Wrong file type {file}&#34;)
        

        cir=format_verilog_org(cir)
        cir=re.sub(r&#34;\n&#34;,r&#34;\n &#34;,cir)
        # cir=re.sub(r&#34;module&#34;,r&#34;\n module&#34;,cir)
        # cir=re.sub(r&#34;endmodule&#34;,r&#34;endmodule\n&#34;,cir)
        cir=re.sub(r&#34;\\&#34;,&#34;&#34;,cir)
        cir=re.sub(r&#34;\s+module&#34;,r&#34; \n\nmodule&#34;,cir)
        cir=re.sub(r&#34;\s+endmodule&#34;,r&#34; endmodule&#34;,cir)


        top_path=os.path.join(output_dir,f&#34;top{file_name}.v&#34;)

        print(f&#34;\t Writing Output Verilog File to {top_path}&#34;)
        with open(top_path,&#34;w&#34;) as f:
            f.write(cir)
        
        print(&#34;\t Done&#34;)
        yosys.verify_verilog(top_path,self.top_module_name)
        

        print(&#34;Done Generating Output Verilog File&#34;)



    def gen_verification_files(self,file_name=&#34;&#34;,output_dir=r&#34;/mnt/d/alis_files/LAPTOP/alis_files/university_files/PROJECTS_2022-2023/FYP/Circuits/top&#34;):
        # r&#34;/mnt/d/alis_files/LAPTOP/alis_files/university_files/PROJECTS_2022-2023/FYP/Circuits/top&#34;
        # self.update_LLverilog()
        print(&#34;Generating Verification Files&#34;)
        # print(&#34;\t Updating Logic Locked Verilog Code&#34;)
        # self.update_LLverilog()
        print(f&#34;\t Generating Miter Circuit Verilog and Testbench&#34;)
        cir,testbench=gen_miterCircuit(self.gate_level_flattened,self.LLverilog,self.postsat_lib+&#34;\n\n\n&#34;+self.gate_lib,self.top_module_name,self.top_module.bitkey,self.top_module.io[&#34;Clock_pins&#34;])

        cir=re.sub(r&#34;\n&#34;,r&#34;\n &#34;,cir)
        cir=re.sub(r&#34; module&#34;,r&#34;module&#34;,cir)
        cir=re.sub(r&#34; endmodule&#34;,r&#34;endmodule&#34;,cir)


        top_path=os.path.join(output_dir,f&#34;top{file_name}.v&#34;)
        test_path=os.path.join(output_dir,f&#34;testbench{file_name}.sv&#34;)
        # print(top_path,test_path)
        print(f&#34;\t Writing miter circuit verilog to {top_path}&#34;)
        with open(top_path,&#34;w&#34;) as f:
            f.write(cir)
        print(&#34;\t Done&#34;)

        print(f&#34;\t Writing miter circuit testbench to {test_path}&#34;)
        with open(test_path,&#34;w&#34;) as f:
            f.write(testbench)
        print(&#34;\t Done&#34;)
        
        print(&#34;\t Verifying Miter circuit top.v&#34;)
        yosys.verify_verilog(top_path,&#39;top&#39;)
        print(&#34;\t Verification Done Without Error&#34;)
        print(&#34;Done Generating Verification Files&#34;)




    def gen_results(self,org=True):
        gate_count=0
        for i in self.top_module.gates:
            gate_count+=len(self.top_module.gates[i])
        
        if(org):
            self.org_gate_count=gate_count
            return gate_count
        else:
            self.LL_gate_count=gate_count
            FF_count=0
            for i in self.top_module.FF_tech:
                FF_count+=len(self.top_module.FF_tech[i])

            overhead=(gate_count-self.org_gate_count)*100/gate_count
            return gate_count,overhead,FF_count
            print(&#34;Overhead in Number of Gates: &#34;,(gate_count-self.org_gate_count)*100/gate_count)
            print(&#34;Expected Overhead in Number of Flip-Flops: &#34;,(gate_count-self.org_gate_count)*100/FF_count)
            






















# // module locked(inputs, key, out);
# // input [7:0] inputs;
# // input [7:0] key;
# // output [1:0]out;
# // sarlock s(.inputs(inputs), .key(key), .lock_out(out[0]));
# // sarlock s1(.inputs(inputs), .key(key), .lock_out(out[1]));
# // endmodule

# // module ckt(a,b,c);
# // input [3:0] a,b;
# // output [4:0] c;
# // assign     c = a + b;
# // endmodule

# // module sarlock (inputs, key, lock_out);
# // input [7:0] inputs;
# // input [7:0] key;
# // output lock_out;
# // wire [4:0]ckt_out; 
# // reg keyx = 8&#39;b01101101;
# // assign lock_out =ckt_out[0]^( (inputs == key) &amp; (inputs != keyx));
# // ckt c(.a(inputs[3:0]), .b(inputs[7:4]), .c(ckt_out));
# // endmodule</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.Netlist.AST.AST"><code class="flex name class">
<span>class <span class="ident">AST</span></span>
<span>(</span><span>file_path, top=None, rw='w', flag='v', filename=None, vlibpath='vlib/mycells.v', sub_modules=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AST:
    &#34;&#34;&#34;

    
    &#34;&#34;&#34;
    def __init__(self,
                 file_path,
                 top=None,
                 rw = &#39;w&#39;,
                 flag = &#39;v&#39;,
                 filename=None,
                 vlibpath=&#34;vlib/mycells.v&#34;,
                 sub_modules=None
                 ):
        self.LLverilog = &#34;&#34;
        self.postsat_lib=&#34;&#34;
        if(filename==None):
            self.filename=top
            self.filepath=&#34;./output_files/{}.json&#34;.format(top)
        else:
            self.filename=filename
            self.filepath=&#34;./output_files/{}.json&#34;.format(self.filename)
        if rw == &#39;r&#39;:
            self.read_LLFile(file_path)
        elif rw == &#39;w&#39;:
            if flag == &#39;v&#39;:
                self.verilog = open(file_path).read()
                
                if(sub_modules!=None):
                    if(type(sub_modules)==list):
                        for files in sub_modules:
                            self.verilog+=open(files).read()
                    else:
                        self.verilog+=open(sub_modules).read()
                
                tmp_file_path=f&#34;./tmp/tmp_verilog_{top}.v&#34;
                with open(tmp_file_path,&#34;w&#34;) as f:
                    f.write(self.verilog)
                # self.verilog=format_verilog_org(self.verilog)
                print(&#34;Verifiying Input Verilog File&#34;)
                yosys.verify_verilog(tmp_file_path,top)
                print(&#34;Input Verilog File Verified Without Issue&#34;)
                os.remove(tmp_file_path)
                
            elif flag == &#39;b&#39;:
                self.bench = open(file_path).read()
                self.verilog = conv.bench_to_verilog(self.bench)
            else:
                Exception(&#34;Enter either &#39;v&#39; (for verilog) or &#39;b&#39; (for bench)&#34;)
            
            self.synthesized_verilog = None
            self.extracted_modules = None
            self.top_module = module()
            self.modules = {}
            # self.linkages={}
            self.top_module_name=top
            self.gate_lib=open(vlibpath).read()
            self.gen_LLFile()
            self.writeLLFile() 
        else:
            Exception(&#34;Enter either &#39;r&#39; (for read) or &#39;w&#39; (for write)&#34;)
        
    def gen_LLFile(self):
        print(&#34;Generating Logic Locking AST File&#34;)
        self.synthesized_verilog = yosys.synthesize_verilog(self.verilog,top=self.top_module_name)#,flag=&#34;dont_flatten&#34;
        self.gate_level_flattened=self.synthesized_verilog
        # self.gate_level_flattened = synthesize_verilog(self.verilog,top=self.top_module_name)
        self.flatten_bench = conv.verilog_to_bench(self.gate_level_flattened)

        self.modules_techmap = utils.module_extraction(self.synthesized_verilog)
        self.extracted_modules = utils.module_extraction(self.synthesized_verilog)
        self.no_of_modules = len(self.extracted_modules)

        self.sub_modules_data()
        self.gen_graph_links()

        print(&#34;Done Generating Logic Locking AST File&#34;)
            # self.modules[i].bin_graph()
        
        # self.gen_module_connections()        
        
    def sub_modules_data(self):
        for key in self.extracted_modules:
            self.modules[key]=module()
            self.modules[key].module_name = key
            self.modules[key].org_code_verilog = self.extracted_modules[key]
            self.modules[key].gate_level_verilog = self.modules_techmap[key]
            self.modules[key].gates,self.modules[key].linkages,tmp = utils.gates_module_extraction(self.modules[key].gate_level_verilog)            
            self.modules[key].FF_tech,self.modules[key].Clock_pins,self.modules[key].Reset_pins=tmp


            # print(self.modules[key].linkages.keys())

            inputs, input_ports = extract_io_v(self.modules[key].org_code_verilog)
            outputs, output_ports = extract_io_v(self.modules[key].org_code_verilog, &#34;output&#34;)
            wire, _ = extract_io_v(self.modules[key].gate_level_verilog, &#34;wire&#34;)
            wire={key:wire[key]  for key in get_difference_abs(wire.keys(),inputs.keys(),outputs.keys())}


            for i in self.modules[key].Clock_pins:
                if((&#34;1&#39;&#34; in i) or (i not in inputs.keys())):
                    self.modules[key].Clock_pins.remove(i)
            # print(&#34;N4944&#34; in  wire.keys())
            # print(get_diference(wire.keys(),outputs.keys()))
            # print(&#34;HERE&#34;,wire[&#34;cpuregs[5]&#34;])
            
            # print(&#34;N1947&#34; in outputs.keys())
            # print(self.modules[key].gates)
            self.modules[key].io = dict({&#34;Clock_pins&#34;:self.modules[key].Clock_pins,&#34;Reset_pins&#34;:self.modules[key].Reset_pins,&#39;wires&#39;:wire,&#39;inputs&#39;:inputs,&#39;outputs&#39;:outputs,&#39;input_ports&#39;:input_ports,&#39;output_ports&#39;:output_ports})
            self.modules[key].gen_graph()
        self.top_module=self.modules[self.top_module_name]
            
    def writeLLFile(self):
        print(&#34;Writing LL file&#34;)
        self.update_LLverilog()
        ast_dict = dict({&#34;orginal_code&#34; : self.verilog, &#34;gate_lib&#34;:self.gate_lib,&#34;gate_level_flattened&#34; : self.gate_level_flattened,&#34;Bench_format_flattened&#34; : self.flatten_bench, &#34;gate_level_not_flattened&#34; : self.synthesized_verilog, &#34;top_module_name&#34; : self.top_module_name,&#34;Total_number_of_modules&#34;:self.no_of_modules,&#34;LL_gatelevel_verilog&#34;:self.LLverilog,&#34;bitkey&#34;:self.top_module.bitkey})
        # top_dict = dict({&#34;Verilog&#34;: self.top_module.org_code_verilog, &#34;Synthesized_verilog&#34; : self.top_module.gate_level_verilog, &#34;Total_number_of_modules&#34;:self.no_of_modules, &#34;io&#34;:self.top_module.io, &#34;gates&#34;: self.top_module.gates, &#34;links&#34; : self.top_module.linkages, &#34;DiGraph&#34;:self.top_module.base64_data})
        # top_dict = dict({&#34;Total_number_of_modules&#34;:self.no_of_modules, &#34;io&#34;:self.top_module.io, &#34;gates&#34;: self.top_module.gates, &#34;links&#34; : self.top_module.linkages, &#34;DiGraph&#34;:self.top_module.base64_data})

        sub_dict = {}
        for key in list(self.modules.keys()):
            self.modules[key].bin_graph()
            sub_dict[key] = dict({&#34;Verilog&#34;: self.modules[key].org_code_verilog, &#34;Synthesized_verilog&#34; : self.modules[key].gate_level_verilog,&#34;lockingdata&#34;:self.modules[key].lockingdata,&#34;DiGraph&#34;:self.modules[key].base64_data, &#34;io&#34;:self.modules[key].io, &#34;gates&#34;: self.modules[key].gates,&#34;FF&#34;:self.modules[key].FF_tech,&#34;links&#34; : self.modules[key].linkages})#&#34;postSAT_modules&#34; : self.modules[key].postSAT_modules, &#34;links&#34; : self.modules[key].linkages


        ast = dict({&#34;AST&#34;:ast_dict,&#34;modules&#34;: sub_dict})

        json_file = json.dumps(ast, indent = 4)
        with open(self.filepath, &#34;w&#34;) as verilog_ast:
            verilog_ast.write(json_file)
        print(&#34;Done Writing LL file&#34;)

    def gen_graph_links(self):
        def process_node(R,module):
            if(&#34;:&#34; in R):
                node,startbit,endbit=re.findall(&#34;(.*)\[(\d+):?(\d*)\]&#34;,R)[0]
                endbit,startbit=int(endbit),int(startbit)
            elif(&#34;[&#34; in R):
                node,bit=re.findall(&#34;(.*)\[(\d+)\]&#34;,R)[0]
                endbit,startbit=int(bit),int(bit)
            else:
                node=R
                endbit,startbit=None,None

            if(node in module.io[&#39;inputs&#39;]):
                Node=module.io[&#39;inputs&#39;][node]
                type=&#39;input&#39;
            elif(node in module.io[&#39;outputs&#39;]):
                Node=module.io[&#39;outputs&#39;][node]
                type=&#39;output&#39;
            elif(node in module.io[&#39;wires&#39;]):
                Node=module.io[&#39;wires&#39;][node]
                type=&#39;wire&#39;
            else:
                print(module.module_name,R)
                raise Exception(&#34;NODE NOT FOUND&#34;)

            if(endbit==None):
                # print(Node)
                if(Node[&#39;bits&#39;]==1):
                    endbit=0
                    startbit=0
                else:
                    endbit=Node[&#39;endbit&#39;]
                    startbit=Node[&#39;startbit&#39;]
                    
            return node,type,endbit,startbit

        def process_links(module):
            links=module.linkages
            for ii in links:
                i=links[ii]
                module_node_name=&#34;module#&#34;+ii
                module.circuitgraph.add_node(module_node_name, type=&#34;module&#34;,module_name=i[&#39;module_name&#39;],init_name=ii)

                for x in i[&#39;links&#39;]:
                    L,R,T=x
                    node,type,endbit,startbit=process_node(R,module)
                    if(T==&#34;I&#34;):
                        if(endbit==0):
                            module.circuitgraph.add_node(node,type=type,port=node)
                            module.circuitgraph.add_edge(node,module_node_name)
                        else:
                            # print(R,node,module_node_name)
                            for k in range(startbit,endbit+1):
                                module.circuitgraph.add_node(node+f&#34;[{k}]&#34;,type=type,port=node)
                                module.circuitgraph.add_edge(node+f&#34;[{k}]&#34;,module_node_name)
                    elif(T==&#34;O&#34;):
                        if(endbit==0):
                            module.circuitgraph.add_node(node,type=type,port=node)
                            module.circuitgraph.add_edge(module_node_name,node)
                        else:
                            for k in range(startbit,endbit+1):
                                module.circuitgraph.add_node(node+f&#34;[{k}]&#34;,type=type,port=node)
                                module.circuitgraph.add_edge(module_node_name,node+f&#34;[{k}]&#34;)
                    else:
                        raise Exception(&#34;NODE NOT FOUND&#34;)
   
                # if(L in self.modules[i[&#39;module_name&#39;]].io[&#39;inputs&#39;]):
                #     for k in range(startbit,endbit+1):
                #         module.circuitgraph.add_node(node+f&#34;[{k}]&#34;,type=type,port=node)
                #         module.circuitgraph.add_edge(node+f&#34;[{k}]&#34;,module_node_name)
                # elif(L in self.modules[i[&#39;module_name&#39;]].io[&#39;outputs&#39;]):
                #     for k in range(startbit,endbit+1):
                #         module.circuitgraph.add_node(node+f&#34;[{k}]&#34;,type=type,port=node)
                #         module.circuitgraph.add_edge(module_node_name,node+f&#34;[{k}]&#34;)
                # else:
                #     raise Exception(&#34;NODE NOT FOUND&#34;)
        
        for i in self.modules:
            process_links(self.modules[i])

    def read_LLFile(self, file_path):
        print(&#34;Reading LL file&#34;)
        print(&#34;\t Loading json file&#34;)
        with open(file_path) as json_file:
            verilog_ast = json.load(json_file)
        
        print(&#34;\t Done Loading json file&#34;)

        print(&#34;\t Loading Top module in AST&#34;)
        self.top_module = module()
        self.modules = {}
        self.verilog =  verilog_ast[&#34;AST&#34;][&#34;orginal_code&#34;]
        self.gate_level_flattened = verilog_ast[&#34;AST&#34;][&#34;gate_level_flattened&#34;]
        self.synthesized_verilog = verilog_ast[&#34;AST&#34;][&#34;gate_level_not_flattened&#34;]
        self.top_module_name  = verilog_ast[&#34;AST&#34;][&#34;top_module_name&#34;]
        self.no_of_modules = verilog_ast[&#34;AST&#34;][&#34;Total_number_of_modules&#34;]
        self.flatten_bench=verilog_ast[&#34;AST&#34;][&#34;Bench_format_flattened&#34;]
        self.gate_lib=verilog_ast[&#34;AST&#34;][&#34;gate_lib&#34;]
        # self.linkages=verilog_ast[&#34;linkages&#34;]
        print(f&#34;\t Done Loading Top module {self.top_module_name} in AST&#34;)

        keys = list((verilog_ast[&#34;modules&#34;]).keys())
        print(&#34;\t Loading module data in AST&#34;)
        for i in keys:
            print(f&#34;\t\t Loading module {i} in AST&#34;)
            self.modules[i]=module()
            self.modules[i].module_name = i
            self.modules[i].org_code_verilog = verilog_ast[&#34;modules&#34;][i][&#34;Verilog&#34;]
            self.modules[i].gate_level_verilog = verilog_ast[&#34;modules&#34;][i][&#34;Synthesized_verilog&#34;]
            self.modules[i].io = verilog_ast[&#34;modules&#34;][i][&#34;io&#34;]
            self.modules[i].gates = verilog_ast[&#34;modules&#34;][i][&#34;gates&#34;]
            self.modules[i].linkages = verilog_ast[&#34;modules&#34;][i][&#34;links&#34;]
            self.modules[i].FF_tech=verilog_ast[&#34;modules&#34;][i][&#34;FF&#34;]
            # self.modules[i].postSAT_modules = verilog_ast[&#34;modules&#34;][i][&#34;postSAT_modules&#34;]
            self.modules[i].lockingdata=verilog_ast[&#34;modules&#34;][i][&#34;lockingdata&#34;]
            #Decode the base64 string back to binary
            # Decode the binary string back to a graph object
            self.modules[i].base64_data = verilog_ast[&#34;modules&#34;][i][&#34;DiGraph&#34;]
            self.modules[i].circuitgraph = pickle.loads(base64.b64decode(self.modules[i].base64_data.encode(&#39;utf-8&#39;)))
            print(f&#34;\t\t Done Loading module {i} in AST&#34;)
        print(&#34;\t Done Loading module data in AST&#34;)
        self.top_module=self.modules[self.top_module_name]
        self.top_module.bitkey=verilog_ast[&#34;AST&#34;][&#34;bitkey&#34;]
        print(&#34;Done Reading LL file&#34;)
    
    # def gen_module_connections(self):
    #     self.module_connections = nx.DiGraph()
    #     for i in self.modules:
    #         tmpi=self.modules[i]
    #         for jj in tmpi.linkages:
    #             j=tmpi.linkages[jj]
    #             module_name = j[&#39;module_name&#39;]
    #             init_name = jj  
    #             # Check if an edge already exists in the graph
    #             if self.module_connections.has_edge(i, module_name):
    #                 # If an edge already exists, update its attributes without overwriting
    #                 # existing ones
    #                 tmp=[self.module_connections[i][module_name][&#39;init_name&#39;]]
    #                 tmp.append(init_name)
    #                 # print(tmp)
    #                 self.module_connections[i][module_name].update({&#39;init_name&#39;: tmp})
    #             else:
    #                 # If no edge exists, add a new edge with the specified attributes
    #                 self.module_connections.add_edge(i, module_name, init_name=init_name) 

    
    # def save_module_connections(self):
    #     save_graph(self.module_connections)
    

    # def update_org_verilog(self):
    #     self.gate_level_flattened=&#34;&#34;
    #     for i in self.modules:
    #         self.modules[i].gen_org_verilog()
    #         self.LLverilog=&#34;&#34;
    #         self.gate_level_flattened+=self.top_module.gate_level_verilog+&#34;\n&#34;
    #         for i in self.modules:
    #             if(i!=self.top_module_name):
    #                 self.gate_level_flattened+=self.modules[i].gate_level_verilog+&#34;\n&#34;


    def update_LLverilog(self):
        for i in self.modules:
            if(self.modules[i].change_flag==1):
                self.modules[i].gen_graph()
        self.gen_graph_links()
        
        
        
        if(&#34;lockingkeyinput&#34; in self.top_module.io[&#34;inputs&#34;]):
            print(&#34;\t Updating Logic Locked Verilog Code&#34;)
            for i in self.modules:
                self.modules[i].gen_LL_verilog()
            self.LLverilog=&#34;&#34;
            self.LLverilog+=self.top_module.module_LLverilog+&#34;\n&#34;
            for i in self.modules:
                if(i!=self.top_module_name):
                    self.LLverilog+=self.modules[i].module_LLverilog+&#34;\n&#34;
            
            self.postsat_lib=&#34;&#34;
            for i in self.modules:
                tmpi=self.modules[i]
                for j in tmpi.linkages:
                    self.postsat_lib+=&#34;\n&#34;+tmpi.linkages[j][&#39;code&#39;]+&#34;\n&#34;
            print(&#34;\t Done Updating Logic Locked Verilog Code&#34;)
        else:
            print(&#34;\t Netlist Not Locked, No Update to Peform&#34;)


    def write_Verilog_File(self,file=&#34;LL&#34;,file_name=&#34;&#34;,output_dir=r&#34;./tmp/&#34;):
        print(&#34;Generating Output Verilog File&#34;)
        if(file==&#34;LL&#34;):
            cir=self.LLverilog+&#34;\n\n\n&#34;+self.postsat_lib+&#34;\n\n\n&#34;+self.gate_lib
            cir=re.sub(r&#34;\n&#34;,r&#34;\n &#34;,cir)
            cir=re.sub(r&#34; module&#34;,r&#34;module&#34;,cir)
            cir=re.sub(r&#34; endmodule&#34;,r&#34;endmodule&#34;,cir)

            bits=self.top_module.io[&#34;inputs&#34;][&#34;lockingkeyinput&#34;][&#39;bits&#39;]

            cir=yosys.synthesize_verilog_flatten_gate(verilog=cir,top=self.top_module_name)
            cir=f&#34;// lockingkey = {bits}&#39;b{self.top_module.bitkey} \n&#34;+cir
        elif(file==&#34;org&#34;):
            cir=self.gate_level_flattened + &#34;\n\n\n&#34; + self.gate_lib
            cir=re.sub(r&#34;\n&#34;,r&#34;\n &#34;,cir)
            cir=re.sub(r&#34; module&#34;,r&#34;module&#34;,cir)
            cir=re.sub(r&#34; endmodule&#34;,r&#34;endmodule&#34;,cir)

            cir=yosys.synthesize_verilog_flatten_gate(verilog=cir,top=self.top_module_name)
        else:
            raise Exception(f&#34;Wrong file type {file}&#34;)
        

        cir=format_verilog_org(cir)
        cir=re.sub(r&#34;\n&#34;,r&#34;\n &#34;,cir)
        # cir=re.sub(r&#34;module&#34;,r&#34;\n module&#34;,cir)
        # cir=re.sub(r&#34;endmodule&#34;,r&#34;endmodule\n&#34;,cir)
        cir=re.sub(r&#34;\\&#34;,&#34;&#34;,cir)
        cir=re.sub(r&#34;\s+module&#34;,r&#34; \n\nmodule&#34;,cir)
        cir=re.sub(r&#34;\s+endmodule&#34;,r&#34; endmodule&#34;,cir)


        top_path=os.path.join(output_dir,f&#34;top{file_name}.v&#34;)

        print(f&#34;\t Writing Output Verilog File to {top_path}&#34;)
        with open(top_path,&#34;w&#34;) as f:
            f.write(cir)
        
        print(&#34;\t Done&#34;)
        yosys.verify_verilog(top_path,self.top_module_name)
        

        print(&#34;Done Generating Output Verilog File&#34;)



    def gen_verification_files(self,file_name=&#34;&#34;,output_dir=r&#34;/mnt/d/alis_files/LAPTOP/alis_files/university_files/PROJECTS_2022-2023/FYP/Circuits/top&#34;):
        # r&#34;/mnt/d/alis_files/LAPTOP/alis_files/university_files/PROJECTS_2022-2023/FYP/Circuits/top&#34;
        # self.update_LLverilog()
        print(&#34;Generating Verification Files&#34;)
        # print(&#34;\t Updating Logic Locked Verilog Code&#34;)
        # self.update_LLverilog()
        print(f&#34;\t Generating Miter Circuit Verilog and Testbench&#34;)
        cir,testbench=gen_miterCircuit(self.gate_level_flattened,self.LLverilog,self.postsat_lib+&#34;\n\n\n&#34;+self.gate_lib,self.top_module_name,self.top_module.bitkey,self.top_module.io[&#34;Clock_pins&#34;])

        cir=re.sub(r&#34;\n&#34;,r&#34;\n &#34;,cir)
        cir=re.sub(r&#34; module&#34;,r&#34;module&#34;,cir)
        cir=re.sub(r&#34; endmodule&#34;,r&#34;endmodule&#34;,cir)


        top_path=os.path.join(output_dir,f&#34;top{file_name}.v&#34;)
        test_path=os.path.join(output_dir,f&#34;testbench{file_name}.sv&#34;)
        # print(top_path,test_path)
        print(f&#34;\t Writing miter circuit verilog to {top_path}&#34;)
        with open(top_path,&#34;w&#34;) as f:
            f.write(cir)
        print(&#34;\t Done&#34;)

        print(f&#34;\t Writing miter circuit testbench to {test_path}&#34;)
        with open(test_path,&#34;w&#34;) as f:
            f.write(testbench)
        print(&#34;\t Done&#34;)
        
        print(&#34;\t Verifying Miter circuit top.v&#34;)
        yosys.verify_verilog(top_path,&#39;top&#39;)
        print(&#34;\t Verification Done Without Error&#34;)
        print(&#34;Done Generating Verification Files&#34;)




    def gen_results(self,org=True):
        gate_count=0
        for i in self.top_module.gates:
            gate_count+=len(self.top_module.gates[i])
        
        if(org):
            self.org_gate_count=gate_count
            return gate_count
        else:
            self.LL_gate_count=gate_count
            FF_count=0
            for i in self.top_module.FF_tech:
                FF_count+=len(self.top_module.FF_tech[i])

            overhead=(gate_count-self.org_gate_count)*100/gate_count
            return gate_count,overhead,FF_count
            print(&#34;Overhead in Number of Gates: &#34;,(gate_count-self.org_gate_count)*100/gate_count)
            print(&#34;Expected Overhead in Number of Flip-Flops: &#34;,(gate_count-self.org_gate_count)*100/FF_count)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.Netlist.AST.AST.gen_LLFile"><code class="name flex">
<span>def <span class="ident">gen_LLFile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_LLFile(self):
    print(&#34;Generating Logic Locking AST File&#34;)
    self.synthesized_verilog = yosys.synthesize_verilog(self.verilog,top=self.top_module_name)#,flag=&#34;dont_flatten&#34;
    self.gate_level_flattened=self.synthesized_verilog
    # self.gate_level_flattened = synthesize_verilog(self.verilog,top=self.top_module_name)
    self.flatten_bench = conv.verilog_to_bench(self.gate_level_flattened)

    self.modules_techmap = utils.module_extraction(self.synthesized_verilog)
    self.extracted_modules = utils.module_extraction(self.synthesized_verilog)
    self.no_of_modules = len(self.extracted_modules)

    self.sub_modules_data()
    self.gen_graph_links()

    print(&#34;Done Generating Logic Locking AST File&#34;)
        # self.modules[i].bin_graph()
    
    # self.gen_module_connections()        </code></pre>
</details>
</dd>
<dt id="src.Netlist.AST.AST.gen_graph_links"><code class="name flex">
<span>def <span class="ident">gen_graph_links</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_graph_links(self):
    def process_node(R,module):
        if(&#34;:&#34; in R):
            node,startbit,endbit=re.findall(&#34;(.*)\[(\d+):?(\d*)\]&#34;,R)[0]
            endbit,startbit=int(endbit),int(startbit)
        elif(&#34;[&#34; in R):
            node,bit=re.findall(&#34;(.*)\[(\d+)\]&#34;,R)[0]
            endbit,startbit=int(bit),int(bit)
        else:
            node=R
            endbit,startbit=None,None

        if(node in module.io[&#39;inputs&#39;]):
            Node=module.io[&#39;inputs&#39;][node]
            type=&#39;input&#39;
        elif(node in module.io[&#39;outputs&#39;]):
            Node=module.io[&#39;outputs&#39;][node]
            type=&#39;output&#39;
        elif(node in module.io[&#39;wires&#39;]):
            Node=module.io[&#39;wires&#39;][node]
            type=&#39;wire&#39;
        else:
            print(module.module_name,R)
            raise Exception(&#34;NODE NOT FOUND&#34;)

        if(endbit==None):
            # print(Node)
            if(Node[&#39;bits&#39;]==1):
                endbit=0
                startbit=0
            else:
                endbit=Node[&#39;endbit&#39;]
                startbit=Node[&#39;startbit&#39;]
                
        return node,type,endbit,startbit

    def process_links(module):
        links=module.linkages
        for ii in links:
            i=links[ii]
            module_node_name=&#34;module#&#34;+ii
            module.circuitgraph.add_node(module_node_name, type=&#34;module&#34;,module_name=i[&#39;module_name&#39;],init_name=ii)

            for x in i[&#39;links&#39;]:
                L,R,T=x
                node,type,endbit,startbit=process_node(R,module)
                if(T==&#34;I&#34;):
                    if(endbit==0):
                        module.circuitgraph.add_node(node,type=type,port=node)
                        module.circuitgraph.add_edge(node,module_node_name)
                    else:
                        # print(R,node,module_node_name)
                        for k in range(startbit,endbit+1):
                            module.circuitgraph.add_node(node+f&#34;[{k}]&#34;,type=type,port=node)
                            module.circuitgraph.add_edge(node+f&#34;[{k}]&#34;,module_node_name)
                elif(T==&#34;O&#34;):
                    if(endbit==0):
                        module.circuitgraph.add_node(node,type=type,port=node)
                        module.circuitgraph.add_edge(module_node_name,node)
                    else:
                        for k in range(startbit,endbit+1):
                            module.circuitgraph.add_node(node+f&#34;[{k}]&#34;,type=type,port=node)
                            module.circuitgraph.add_edge(module_node_name,node+f&#34;[{k}]&#34;)
                else:
                    raise Exception(&#34;NODE NOT FOUND&#34;)

            # if(L in self.modules[i[&#39;module_name&#39;]].io[&#39;inputs&#39;]):
            #     for k in range(startbit,endbit+1):
            #         module.circuitgraph.add_node(node+f&#34;[{k}]&#34;,type=type,port=node)
            #         module.circuitgraph.add_edge(node+f&#34;[{k}]&#34;,module_node_name)
            # elif(L in self.modules[i[&#39;module_name&#39;]].io[&#39;outputs&#39;]):
            #     for k in range(startbit,endbit+1):
            #         module.circuitgraph.add_node(node+f&#34;[{k}]&#34;,type=type,port=node)
            #         module.circuitgraph.add_edge(module_node_name,node+f&#34;[{k}]&#34;)
            # else:
            #     raise Exception(&#34;NODE NOT FOUND&#34;)
    
    for i in self.modules:
        process_links(self.modules[i])</code></pre>
</details>
</dd>
<dt id="src.Netlist.AST.AST.gen_results"><code class="name flex">
<span>def <span class="ident">gen_results</span></span>(<span>self, org=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_results(self,org=True):
    gate_count=0
    for i in self.top_module.gates:
        gate_count+=len(self.top_module.gates[i])
    
    if(org):
        self.org_gate_count=gate_count
        return gate_count
    else:
        self.LL_gate_count=gate_count
        FF_count=0
        for i in self.top_module.FF_tech:
            FF_count+=len(self.top_module.FF_tech[i])

        overhead=(gate_count-self.org_gate_count)*100/gate_count
        return gate_count,overhead,FF_count
        print(&#34;Overhead in Number of Gates: &#34;,(gate_count-self.org_gate_count)*100/gate_count)
        print(&#34;Expected Overhead in Number of Flip-Flops: &#34;,(gate_count-self.org_gate_count)*100/FF_count)</code></pre>
</details>
</dd>
<dt id="src.Netlist.AST.AST.gen_verification_files"><code class="name flex">
<span>def <span class="ident">gen_verification_files</span></span>(<span>self, file_name='', output_dir='/mnt/d/alis_files/LAPTOP/alis_files/university_files/PROJECTS_2022-2023/FYP/Circuits/top')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_verification_files(self,file_name=&#34;&#34;,output_dir=r&#34;/mnt/d/alis_files/LAPTOP/alis_files/university_files/PROJECTS_2022-2023/FYP/Circuits/top&#34;):
    # r&#34;/mnt/d/alis_files/LAPTOP/alis_files/university_files/PROJECTS_2022-2023/FYP/Circuits/top&#34;
    # self.update_LLverilog()
    print(&#34;Generating Verification Files&#34;)
    # print(&#34;\t Updating Logic Locked Verilog Code&#34;)
    # self.update_LLverilog()
    print(f&#34;\t Generating Miter Circuit Verilog and Testbench&#34;)
    cir,testbench=gen_miterCircuit(self.gate_level_flattened,self.LLverilog,self.postsat_lib+&#34;\n\n\n&#34;+self.gate_lib,self.top_module_name,self.top_module.bitkey,self.top_module.io[&#34;Clock_pins&#34;])

    cir=re.sub(r&#34;\n&#34;,r&#34;\n &#34;,cir)
    cir=re.sub(r&#34; module&#34;,r&#34;module&#34;,cir)
    cir=re.sub(r&#34; endmodule&#34;,r&#34;endmodule&#34;,cir)


    top_path=os.path.join(output_dir,f&#34;top{file_name}.v&#34;)
    test_path=os.path.join(output_dir,f&#34;testbench{file_name}.sv&#34;)
    # print(top_path,test_path)
    print(f&#34;\t Writing miter circuit verilog to {top_path}&#34;)
    with open(top_path,&#34;w&#34;) as f:
        f.write(cir)
    print(&#34;\t Done&#34;)

    print(f&#34;\t Writing miter circuit testbench to {test_path}&#34;)
    with open(test_path,&#34;w&#34;) as f:
        f.write(testbench)
    print(&#34;\t Done&#34;)
    
    print(&#34;\t Verifying Miter circuit top.v&#34;)
    yosys.verify_verilog(top_path,&#39;top&#39;)
    print(&#34;\t Verification Done Without Error&#34;)
    print(&#34;Done Generating Verification Files&#34;)</code></pre>
</details>
</dd>
<dt id="src.Netlist.AST.AST.read_LLFile"><code class="name flex">
<span>def <span class="ident">read_LLFile</span></span>(<span>self, file_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_LLFile(self, file_path):
    print(&#34;Reading LL file&#34;)
    print(&#34;\t Loading json file&#34;)
    with open(file_path) as json_file:
        verilog_ast = json.load(json_file)
    
    print(&#34;\t Done Loading json file&#34;)

    print(&#34;\t Loading Top module in AST&#34;)
    self.top_module = module()
    self.modules = {}
    self.verilog =  verilog_ast[&#34;AST&#34;][&#34;orginal_code&#34;]
    self.gate_level_flattened = verilog_ast[&#34;AST&#34;][&#34;gate_level_flattened&#34;]
    self.synthesized_verilog = verilog_ast[&#34;AST&#34;][&#34;gate_level_not_flattened&#34;]
    self.top_module_name  = verilog_ast[&#34;AST&#34;][&#34;top_module_name&#34;]
    self.no_of_modules = verilog_ast[&#34;AST&#34;][&#34;Total_number_of_modules&#34;]
    self.flatten_bench=verilog_ast[&#34;AST&#34;][&#34;Bench_format_flattened&#34;]
    self.gate_lib=verilog_ast[&#34;AST&#34;][&#34;gate_lib&#34;]
    # self.linkages=verilog_ast[&#34;linkages&#34;]
    print(f&#34;\t Done Loading Top module {self.top_module_name} in AST&#34;)

    keys = list((verilog_ast[&#34;modules&#34;]).keys())
    print(&#34;\t Loading module data in AST&#34;)
    for i in keys:
        print(f&#34;\t\t Loading module {i} in AST&#34;)
        self.modules[i]=module()
        self.modules[i].module_name = i
        self.modules[i].org_code_verilog = verilog_ast[&#34;modules&#34;][i][&#34;Verilog&#34;]
        self.modules[i].gate_level_verilog = verilog_ast[&#34;modules&#34;][i][&#34;Synthesized_verilog&#34;]
        self.modules[i].io = verilog_ast[&#34;modules&#34;][i][&#34;io&#34;]
        self.modules[i].gates = verilog_ast[&#34;modules&#34;][i][&#34;gates&#34;]
        self.modules[i].linkages = verilog_ast[&#34;modules&#34;][i][&#34;links&#34;]
        self.modules[i].FF_tech=verilog_ast[&#34;modules&#34;][i][&#34;FF&#34;]
        # self.modules[i].postSAT_modules = verilog_ast[&#34;modules&#34;][i][&#34;postSAT_modules&#34;]
        self.modules[i].lockingdata=verilog_ast[&#34;modules&#34;][i][&#34;lockingdata&#34;]
        #Decode the base64 string back to binary
        # Decode the binary string back to a graph object
        self.modules[i].base64_data = verilog_ast[&#34;modules&#34;][i][&#34;DiGraph&#34;]
        self.modules[i].circuitgraph = pickle.loads(base64.b64decode(self.modules[i].base64_data.encode(&#39;utf-8&#39;)))
        print(f&#34;\t\t Done Loading module {i} in AST&#34;)
    print(&#34;\t Done Loading module data in AST&#34;)
    self.top_module=self.modules[self.top_module_name]
    self.top_module.bitkey=verilog_ast[&#34;AST&#34;][&#34;bitkey&#34;]
    print(&#34;Done Reading LL file&#34;)</code></pre>
</details>
</dd>
<dt id="src.Netlist.AST.AST.sub_modules_data"><code class="name flex">
<span>def <span class="ident">sub_modules_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sub_modules_data(self):
    for key in self.extracted_modules:
        self.modules[key]=module()
        self.modules[key].module_name = key
        self.modules[key].org_code_verilog = self.extracted_modules[key]
        self.modules[key].gate_level_verilog = self.modules_techmap[key]
        self.modules[key].gates,self.modules[key].linkages,tmp = utils.gates_module_extraction(self.modules[key].gate_level_verilog)            
        self.modules[key].FF_tech,self.modules[key].Clock_pins,self.modules[key].Reset_pins=tmp


        # print(self.modules[key].linkages.keys())

        inputs, input_ports = extract_io_v(self.modules[key].org_code_verilog)
        outputs, output_ports = extract_io_v(self.modules[key].org_code_verilog, &#34;output&#34;)
        wire, _ = extract_io_v(self.modules[key].gate_level_verilog, &#34;wire&#34;)
        wire={key:wire[key]  for key in get_difference_abs(wire.keys(),inputs.keys(),outputs.keys())}


        for i in self.modules[key].Clock_pins:
            if((&#34;1&#39;&#34; in i) or (i not in inputs.keys())):
                self.modules[key].Clock_pins.remove(i)
        # print(&#34;N4944&#34; in  wire.keys())
        # print(get_diference(wire.keys(),outputs.keys()))
        # print(&#34;HERE&#34;,wire[&#34;cpuregs[5]&#34;])
        
        # print(&#34;N1947&#34; in outputs.keys())
        # print(self.modules[key].gates)
        self.modules[key].io = dict({&#34;Clock_pins&#34;:self.modules[key].Clock_pins,&#34;Reset_pins&#34;:self.modules[key].Reset_pins,&#39;wires&#39;:wire,&#39;inputs&#39;:inputs,&#39;outputs&#39;:outputs,&#39;input_ports&#39;:input_ports,&#39;output_ports&#39;:output_ports})
        self.modules[key].gen_graph()
    self.top_module=self.modules[self.top_module_name]</code></pre>
</details>
</dd>
<dt id="src.Netlist.AST.AST.update_LLverilog"><code class="name flex">
<span>def <span class="ident">update_LLverilog</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_LLverilog(self):
    for i in self.modules:
        if(self.modules[i].change_flag==1):
            self.modules[i].gen_graph()
    self.gen_graph_links()
    
    
    
    if(&#34;lockingkeyinput&#34; in self.top_module.io[&#34;inputs&#34;]):
        print(&#34;\t Updating Logic Locked Verilog Code&#34;)
        for i in self.modules:
            self.modules[i].gen_LL_verilog()
        self.LLverilog=&#34;&#34;
        self.LLverilog+=self.top_module.module_LLverilog+&#34;\n&#34;
        for i in self.modules:
            if(i!=self.top_module_name):
                self.LLverilog+=self.modules[i].module_LLverilog+&#34;\n&#34;
        
        self.postsat_lib=&#34;&#34;
        for i in self.modules:
            tmpi=self.modules[i]
            for j in tmpi.linkages:
                self.postsat_lib+=&#34;\n&#34;+tmpi.linkages[j][&#39;code&#39;]+&#34;\n&#34;
        print(&#34;\t Done Updating Logic Locked Verilog Code&#34;)
    else:
        print(&#34;\t Netlist Not Locked, No Update to Peform&#34;)</code></pre>
</details>
</dd>
<dt id="src.Netlist.AST.AST.writeLLFile"><code class="name flex">
<span>def <span class="ident">writeLLFile</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeLLFile(self):
    print(&#34;Writing LL file&#34;)
    self.update_LLverilog()
    ast_dict = dict({&#34;orginal_code&#34; : self.verilog, &#34;gate_lib&#34;:self.gate_lib,&#34;gate_level_flattened&#34; : self.gate_level_flattened,&#34;Bench_format_flattened&#34; : self.flatten_bench, &#34;gate_level_not_flattened&#34; : self.synthesized_verilog, &#34;top_module_name&#34; : self.top_module_name,&#34;Total_number_of_modules&#34;:self.no_of_modules,&#34;LL_gatelevel_verilog&#34;:self.LLverilog,&#34;bitkey&#34;:self.top_module.bitkey})
    # top_dict = dict({&#34;Verilog&#34;: self.top_module.org_code_verilog, &#34;Synthesized_verilog&#34; : self.top_module.gate_level_verilog, &#34;Total_number_of_modules&#34;:self.no_of_modules, &#34;io&#34;:self.top_module.io, &#34;gates&#34;: self.top_module.gates, &#34;links&#34; : self.top_module.linkages, &#34;DiGraph&#34;:self.top_module.base64_data})
    # top_dict = dict({&#34;Total_number_of_modules&#34;:self.no_of_modules, &#34;io&#34;:self.top_module.io, &#34;gates&#34;: self.top_module.gates, &#34;links&#34; : self.top_module.linkages, &#34;DiGraph&#34;:self.top_module.base64_data})

    sub_dict = {}
    for key in list(self.modules.keys()):
        self.modules[key].bin_graph()
        sub_dict[key] = dict({&#34;Verilog&#34;: self.modules[key].org_code_verilog, &#34;Synthesized_verilog&#34; : self.modules[key].gate_level_verilog,&#34;lockingdata&#34;:self.modules[key].lockingdata,&#34;DiGraph&#34;:self.modules[key].base64_data, &#34;io&#34;:self.modules[key].io, &#34;gates&#34;: self.modules[key].gates,&#34;FF&#34;:self.modules[key].FF_tech,&#34;links&#34; : self.modules[key].linkages})#&#34;postSAT_modules&#34; : self.modules[key].postSAT_modules, &#34;links&#34; : self.modules[key].linkages


    ast = dict({&#34;AST&#34;:ast_dict,&#34;modules&#34;: sub_dict})

    json_file = json.dumps(ast, indent = 4)
    with open(self.filepath, &#34;w&#34;) as verilog_ast:
        verilog_ast.write(json_file)
    print(&#34;Done Writing LL file&#34;)</code></pre>
</details>
</dd>
<dt id="src.Netlist.AST.AST.write_Verilog_File"><code class="name flex">
<span>def <span class="ident">write_Verilog_File</span></span>(<span>self, file='LL', file_name='', output_dir='./tmp/')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_Verilog_File(self,file=&#34;LL&#34;,file_name=&#34;&#34;,output_dir=r&#34;./tmp/&#34;):
    print(&#34;Generating Output Verilog File&#34;)
    if(file==&#34;LL&#34;):
        cir=self.LLverilog+&#34;\n\n\n&#34;+self.postsat_lib+&#34;\n\n\n&#34;+self.gate_lib
        cir=re.sub(r&#34;\n&#34;,r&#34;\n &#34;,cir)
        cir=re.sub(r&#34; module&#34;,r&#34;module&#34;,cir)
        cir=re.sub(r&#34; endmodule&#34;,r&#34;endmodule&#34;,cir)

        bits=self.top_module.io[&#34;inputs&#34;][&#34;lockingkeyinput&#34;][&#39;bits&#39;]

        cir=yosys.synthesize_verilog_flatten_gate(verilog=cir,top=self.top_module_name)
        cir=f&#34;// lockingkey = {bits}&#39;b{self.top_module.bitkey} \n&#34;+cir
    elif(file==&#34;org&#34;):
        cir=self.gate_level_flattened + &#34;\n\n\n&#34; + self.gate_lib
        cir=re.sub(r&#34;\n&#34;,r&#34;\n &#34;,cir)
        cir=re.sub(r&#34; module&#34;,r&#34;module&#34;,cir)
        cir=re.sub(r&#34; endmodule&#34;,r&#34;endmodule&#34;,cir)

        cir=yosys.synthesize_verilog_flatten_gate(verilog=cir,top=self.top_module_name)
    else:
        raise Exception(f&#34;Wrong file type {file}&#34;)
    

    cir=format_verilog_org(cir)
    cir=re.sub(r&#34;\n&#34;,r&#34;\n &#34;,cir)
    # cir=re.sub(r&#34;module&#34;,r&#34;\n module&#34;,cir)
    # cir=re.sub(r&#34;endmodule&#34;,r&#34;endmodule\n&#34;,cir)
    cir=re.sub(r&#34;\\&#34;,&#34;&#34;,cir)
    cir=re.sub(r&#34;\s+module&#34;,r&#34; \n\nmodule&#34;,cir)
    cir=re.sub(r&#34;\s+endmodule&#34;,r&#34; endmodule&#34;,cir)


    top_path=os.path.join(output_dir,f&#34;top{file_name}.v&#34;)

    print(f&#34;\t Writing Output Verilog File to {top_path}&#34;)
    with open(top_path,&#34;w&#34;) as f:
        f.write(cir)
    
    print(&#34;\t Done&#34;)
    yosys.verify_verilog(top_path,self.top_module_name)
    

    print(&#34;Done Generating Output Verilog File&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.Netlist.AST.module"><code class="flex name class">
<span>class <span class="ident">module</span></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the module object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class module:
    def __init__(self):
        &#34;&#34;&#34;
        Initialize the module object.
        &#34;&#34;&#34;
        self.change_flag=1
        self.org_code_verilog = None
        self.org_code_bench = None
        self.gate_level_verilog = None
        self.module_name = None
        self.gates = None
        self.FF_tech=None
        self.io = None
        self.circuitgraph=None
        self.module_LLverilog=&#34;&#34;
        self.lockingdata={&#34;wires&#34;:[],&#34;gates&#34;:[],&#34;inputs&#34;:[]}
        self.bitkey=&#34;&#34;
        # self.module_LLverilog=None
        # self.module_LLcircuitgraph=None
    
    def gen_graph(self):
        &#34;&#34;&#34;
        Generate the circuit graph.
        &#34;&#34;&#34;
        self.circuitgraph = nx.DiGraph()
        for logic_gate in self.gates:
            for init_name in self.gates[logic_gate]:
                node=self.gates[logic_gate][init_name]
                tmpi=self.gates[logic_gate]
                node_input=node[&#34;inputs&#34;]
                node_output=node[&#34;outputs&#34;]
                node_name=init_name
                port=utils.check_port(node_output)
                self.circuitgraph.add_node(node_name, type=&#34;gate&#34;,logic=logic_gate)

                if(port in self.io[&#34;outputs&#34;]):
                    self.circuitgraph.add_node(node_output, type=&#34;output&#34;)
                    self.circuitgraph.add_edge(node_name, node_output)
                elif(port in self.io[&#34;wires&#34;]):
                    self.circuitgraph.add_node(node_output, type=&#34;wire&#34;)
                    self.circuitgraph.add_edge(node_name, node_output)
                else:
                    print(self.module_name)
                    print(port,node_output)
                    raise Exception(&#34;NODE NOT FOUND&#34;)


                for i in node_input:
                    def tmp():
                        if(&#34;XNOR_117153_&#34; in init_name):
                            print(&#34;HERE212 &#34;,i,node_input,node_name)
                    tmptxt=utils.check_port(i)

                    if(tmptxt in self.io[&#34;inputs&#34;]):
                        self.circuitgraph.add_node(i, type=&#34;input&#34;,port=tmptxt)
                        self.circuitgraph.add_edge(i,node_name)
                    elif(tmptxt in self.io[&#34;outputs&#34;]):
                        self.circuitgraph.add_node(i, type=&#34;output&#34;,port=tmptxt)
                        self.circuitgraph.add_edge(i,node_name)
                        # tmp()
                        # print(i)
                    elif(tmptxt in self.io[&#34;wires&#34;]):
                        self.circuitgraph.add_node(i, type=&#34;wire&#34;,port=tmptxt)
                        self.circuitgraph.add_edge(i,node_name)
                    elif(i in self.io[&#34;wires&#34;]):
                        self.circuitgraph.add_node(i, type=&#34;wire&#34;,port=tmptxt)
                        self.circuitgraph.add_edge(i,node_name)
                    elif(&#34;1&#39;&#34; in i):
                        self.circuitgraph.add_node(i, type=&#34;bit&#34;,value=i)
                        self.circuitgraph.add_edge(i,node_name)
                    else:
                        print(&#34;HERE&#34;)
                        print(self.module_name,&#34; ==&gt;&gt; &#34;,tmptxt,i)
                        raise Exception(&#34;NODE NOT FOUND&#34;)

        # print(&#34;HERE&#34;,self.FF_tech)
        for FF in self.FF_tech:
            for init_name in self.FF_tech[FF]:
                tmpi=self.FF_tech[FF]
                node=tmpi[init_name]
                node_input=node[&#34;inputs&#34;]
                node_output=node[&#34;outputs&#34;]
                node_name=init_name
                
                rst=node.get(&#34;reset&#34;)
                clk=node.get(&#34;clock&#34;)
                self.circuitgraph.add_node(node_name, type=FF,clock=clk,reset=rst)
                # print(init_name)
                



                self.circuitgraph.add_node(clk, type=&#34;input&#34;)
                self.circuitgraph.add_edge(clk, node_name)

                if(rst!=None):
                    self.circuitgraph.add_node(rst, type=&#34;input&#34;)
                    self.circuitgraph.add_edge(rst, node_name)

                port=utils.check_port(node_output)
                if(port in self.io[&#34;outputs&#34;]):
                    self.circuitgraph.add_node(node_output, type=&#34;output&#34;,port=port)
                    self.circuitgraph.add_edge(node_name, node_output)
                elif(port in self.io[&#34;wires&#34;]):
                    self.circuitgraph.add_node(node_output, type=&#34;wire&#34;,port=port)
                    self.circuitgraph.add_edge(node_name, node_output)
                else:
                    print(self.module_name)
                    print(port,node_output)
                    raise Exception(&#34;NODE NOT FOUND&#34;)
                

                tmptxt=utils.check_port(node_input)
                if(tmptxt in self.io[&#34;inputs&#34;]):
                    self.circuitgraph.add_node(node_input, type=&#34;input&#34;,port=tmptxt)
                    self.circuitgraph.add_edge(node_input,node_name)
                elif(tmptxt in self.io[&#34;outputs&#34;]):
                    self.circuitgraph.add_node(node_input, type=&#34;output&#34;,port=tmptxt)
                    self.circuitgraph.add_edge(node_name,node_input)
                elif(tmptxt in self.io[&#34;wires&#34;]):
                    self.circuitgraph.add_node(node_input, type=&#34;wire&#34;,port=tmptxt)
                    self.circuitgraph.add_edge(node_input,node_name)
                elif(node_input in self.io[&#34;wires&#34;]):
                    self.circuitgraph.add_node(node_input, type=&#34;wire&#34;,port=node_input)
                    self.circuitgraph.add_edge(node_input,node_name)
                elif(&#34;1&#39;h&#34; in node_input):
                    self.circuitgraph.add_node(node_input, type=&#34;bit&#34;,value=int(node_input[-1]))
                    self.circuitgraph.add_edge(node_input,node_name)
                else:
                    print(self.module_name)
                    print(tmptxt,i)
                    raise Exception(&#34;NODE NOT FOUND&#34;)

        self.circuitgraph.add_node(&#34;module#&#34;+self.module_name, type=&#34;module&#34;)
        for i in self.io[&#34;outputs&#34;]:
            tmpi=self.io[&#34;outputs&#34;][i]
            if(tmpi[&#39;bits&#39;]==1):
                self.circuitgraph.add_edge(i,&#34;module#&#34;+self.module_name)
            else:
                for k in range(tmpi[&#39;startbit&#39;],tmpi[&#34;endbit&#34;]+1):
                    self.circuitgraph.add_edge(i+f&#34;[{k}]&#34;,&#34;module#&#34;+self.module_name)

        for i in self.io[&#34;inputs&#34;]:
            tmpi=self.io[&#34;inputs&#34;][i]
            if(tmpi[&#39;bits&#39;]==1):
                self.circuitgraph.add_edge(&#34;module#&#34;+self.module_name,i)
            else:
                for k in range(tmpi[&#39;startbit&#39;],tmpi[&#34;endbit&#34;]+1):
                    self.circuitgraph.add_edge(&#34;module#&#34;+self.module_name,i+f&#34;[{k}]&#34;)
        self.change_flag=0

    
    def bin_graph(self):
        &#34;&#34;&#34;
        Encode the circuit graph to a binary string using pickle and encode the binary string to a base64 string.
        &#34;&#34;&#34;
        self.base64_data = base64.b64encode(pickle.dumps(self.circuitgraph)).decode(&#39;utf-8&#39;)

    def nodeio(self,Node)-&gt;None:
        &#34;&#34;&#34;
        Print the outputs and inputs of a node in the circuit graph.
        
        Args:
            Node (str): The name of the node.
        &#34;&#34;&#34;
        print(&#34;Node outputs = &#34;,list(self.circuitgraph.successors(Node))) 
        print(&#34;Node inputs = &#34;,list(self.circuitgraph.predecessors(Node)))    
    
    def save_graph(self,svg=False):
        &#34;&#34;&#34;
        Save the circuit graph as an SVG image.
        
        Args:
            svg (bool): Whether to save the graph as an SVG image (default: False).
        &#34;&#34;&#34;
        utils.save_graph(self.circuitgraph,svg)

    # def gen_org_verilog(self):
    #     self.gate_level_verilog=f&#34;module {self.module_name}({self.io[&#39;input_ports&#39;]}{self.io[&#39;output_ports&#39;][:-1]});\n&#34;
    #     self.gate_level_verilog+=utils.node_to_txt(self.io[&#39;inputs&#39;],mode=&#34;input&#34;)
    #     self.gate_level_verilog+=utils.node_to_txt(self.io[&#39;outputs&#39;],mode=&#34;output&#34;)
    #     self.gate_level_verilog+=utils.node_to_txt(self.io[&#39;wires&#39;],mode=&#34;wire&#34;)
    #     self.gate_level_verilog+=utils.gates_to_txt(self.gates)
    #     self.gate_level_verilog+=utils.FF_to_txt(self.FF_tech)
    #     # self.module_LLverilog+=module_to_txt(self.linkages)
    #     for j in self.linkages:
    #         tmpj=self.linkages[j]
    #         self.gate_level_verilog+=f&#34;{tmpj[&#39;module_name&#39;]} {j}({tmpj[&#39;port&#39;]}); \n&#34;
    #     self.gate_level_verilog+=&#34;endmodule\n&#34;


    def gen_LL_verilog(self):
        &#34;&#34;&#34;
        Generate the LL verilog code for the module.
        &#34;&#34;&#34;
        self.module_LLverilog=f&#34;module {self.module_name}({self.io[&#39;input_ports&#39;]}{self.io[&#39;output_ports&#39;][:-1]});\n&#34;
        self.module_LLverilog+=utils.node_to_txt(self.io[&#39;inputs&#39;],mode=&#34;input&#34;)
        self.module_LLverilog+=utils.node_to_txt(self.io[&#39;outputs&#39;],mode=&#34;output&#34;)
        self.module_LLverilog+=utils.node_to_txt(self.io[&#39;wires&#39;],mode=&#34;wire&#34;)
        self.module_LLverilog+=utils.gates_to_txt(self.gates)
        self.module_LLverilog+=utils.FF_to_txt(self.FF_tech)
        # self.module_LLverilog+=module_to_txt(self.linkages)
        for j in self.linkages:
            tmpj=self.linkages[j]
            self.module_LLverilog+=f&#34;{tmpj[&#39;module_name&#39;]} {j}({tmpj[&#39;port&#39;]}); \n&#34;
        self.module_LLverilog+=&#34;endmodule\n&#34;
        # if(self.postSAT_modules!={}):
        #     self.module_LLverilog+=module_to_txt(self.postSAT_modules)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.Netlist.AST.module.bin_graph"><code class="name flex">
<span>def <span class="ident">bin_graph</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode the circuit graph to a binary string using pickle and encode the binary string to a base64 string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bin_graph(self):
    &#34;&#34;&#34;
    Encode the circuit graph to a binary string using pickle and encode the binary string to a base64 string.
    &#34;&#34;&#34;
    self.base64_data = base64.b64encode(pickle.dumps(self.circuitgraph)).decode(&#39;utf-8&#39;)</code></pre>
</details>
</dd>
<dt id="src.Netlist.AST.module.gen_LL_verilog"><code class="name flex">
<span>def <span class="ident">gen_LL_verilog</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the LL verilog code for the module.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_LL_verilog(self):
    &#34;&#34;&#34;
    Generate the LL verilog code for the module.
    &#34;&#34;&#34;
    self.module_LLverilog=f&#34;module {self.module_name}({self.io[&#39;input_ports&#39;]}{self.io[&#39;output_ports&#39;][:-1]});\n&#34;
    self.module_LLverilog+=utils.node_to_txt(self.io[&#39;inputs&#39;],mode=&#34;input&#34;)
    self.module_LLverilog+=utils.node_to_txt(self.io[&#39;outputs&#39;],mode=&#34;output&#34;)
    self.module_LLverilog+=utils.node_to_txt(self.io[&#39;wires&#39;],mode=&#34;wire&#34;)
    self.module_LLverilog+=utils.gates_to_txt(self.gates)
    self.module_LLverilog+=utils.FF_to_txt(self.FF_tech)
    # self.module_LLverilog+=module_to_txt(self.linkages)
    for j in self.linkages:
        tmpj=self.linkages[j]
        self.module_LLverilog+=f&#34;{tmpj[&#39;module_name&#39;]} {j}({tmpj[&#39;port&#39;]}); \n&#34;
    self.module_LLverilog+=&#34;endmodule\n&#34;
    # if(self.postSAT_modules!={}):
    #     self.module_LLverilog+=module_to_txt(self.postSAT_modules)</code></pre>
</details>
</dd>
<dt id="src.Netlist.AST.module.gen_graph"><code class="name flex">
<span>def <span class="ident">gen_graph</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the circuit graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_graph(self):
    &#34;&#34;&#34;
    Generate the circuit graph.
    &#34;&#34;&#34;
    self.circuitgraph = nx.DiGraph()
    for logic_gate in self.gates:
        for init_name in self.gates[logic_gate]:
            node=self.gates[logic_gate][init_name]
            tmpi=self.gates[logic_gate]
            node_input=node[&#34;inputs&#34;]
            node_output=node[&#34;outputs&#34;]
            node_name=init_name
            port=utils.check_port(node_output)
            self.circuitgraph.add_node(node_name, type=&#34;gate&#34;,logic=logic_gate)

            if(port in self.io[&#34;outputs&#34;]):
                self.circuitgraph.add_node(node_output, type=&#34;output&#34;)
                self.circuitgraph.add_edge(node_name, node_output)
            elif(port in self.io[&#34;wires&#34;]):
                self.circuitgraph.add_node(node_output, type=&#34;wire&#34;)
                self.circuitgraph.add_edge(node_name, node_output)
            else:
                print(self.module_name)
                print(port,node_output)
                raise Exception(&#34;NODE NOT FOUND&#34;)


            for i in node_input:
                def tmp():
                    if(&#34;XNOR_117153_&#34; in init_name):
                        print(&#34;HERE212 &#34;,i,node_input,node_name)
                tmptxt=utils.check_port(i)

                if(tmptxt in self.io[&#34;inputs&#34;]):
                    self.circuitgraph.add_node(i, type=&#34;input&#34;,port=tmptxt)
                    self.circuitgraph.add_edge(i,node_name)
                elif(tmptxt in self.io[&#34;outputs&#34;]):
                    self.circuitgraph.add_node(i, type=&#34;output&#34;,port=tmptxt)
                    self.circuitgraph.add_edge(i,node_name)
                    # tmp()
                    # print(i)
                elif(tmptxt in self.io[&#34;wires&#34;]):
                    self.circuitgraph.add_node(i, type=&#34;wire&#34;,port=tmptxt)
                    self.circuitgraph.add_edge(i,node_name)
                elif(i in self.io[&#34;wires&#34;]):
                    self.circuitgraph.add_node(i, type=&#34;wire&#34;,port=tmptxt)
                    self.circuitgraph.add_edge(i,node_name)
                elif(&#34;1&#39;&#34; in i):
                    self.circuitgraph.add_node(i, type=&#34;bit&#34;,value=i)
                    self.circuitgraph.add_edge(i,node_name)
                else:
                    print(&#34;HERE&#34;)
                    print(self.module_name,&#34; ==&gt;&gt; &#34;,tmptxt,i)
                    raise Exception(&#34;NODE NOT FOUND&#34;)

    # print(&#34;HERE&#34;,self.FF_tech)
    for FF in self.FF_tech:
        for init_name in self.FF_tech[FF]:
            tmpi=self.FF_tech[FF]
            node=tmpi[init_name]
            node_input=node[&#34;inputs&#34;]
            node_output=node[&#34;outputs&#34;]
            node_name=init_name
            
            rst=node.get(&#34;reset&#34;)
            clk=node.get(&#34;clock&#34;)
            self.circuitgraph.add_node(node_name, type=FF,clock=clk,reset=rst)
            # print(init_name)
            



            self.circuitgraph.add_node(clk, type=&#34;input&#34;)
            self.circuitgraph.add_edge(clk, node_name)

            if(rst!=None):
                self.circuitgraph.add_node(rst, type=&#34;input&#34;)
                self.circuitgraph.add_edge(rst, node_name)

            port=utils.check_port(node_output)
            if(port in self.io[&#34;outputs&#34;]):
                self.circuitgraph.add_node(node_output, type=&#34;output&#34;,port=port)
                self.circuitgraph.add_edge(node_name, node_output)
            elif(port in self.io[&#34;wires&#34;]):
                self.circuitgraph.add_node(node_output, type=&#34;wire&#34;,port=port)
                self.circuitgraph.add_edge(node_name, node_output)
            else:
                print(self.module_name)
                print(port,node_output)
                raise Exception(&#34;NODE NOT FOUND&#34;)
            

            tmptxt=utils.check_port(node_input)
            if(tmptxt in self.io[&#34;inputs&#34;]):
                self.circuitgraph.add_node(node_input, type=&#34;input&#34;,port=tmptxt)
                self.circuitgraph.add_edge(node_input,node_name)
            elif(tmptxt in self.io[&#34;outputs&#34;]):
                self.circuitgraph.add_node(node_input, type=&#34;output&#34;,port=tmptxt)
                self.circuitgraph.add_edge(node_name,node_input)
            elif(tmptxt in self.io[&#34;wires&#34;]):
                self.circuitgraph.add_node(node_input, type=&#34;wire&#34;,port=tmptxt)
                self.circuitgraph.add_edge(node_input,node_name)
            elif(node_input in self.io[&#34;wires&#34;]):
                self.circuitgraph.add_node(node_input, type=&#34;wire&#34;,port=node_input)
                self.circuitgraph.add_edge(node_input,node_name)
            elif(&#34;1&#39;h&#34; in node_input):
                self.circuitgraph.add_node(node_input, type=&#34;bit&#34;,value=int(node_input[-1]))
                self.circuitgraph.add_edge(node_input,node_name)
            else:
                print(self.module_name)
                print(tmptxt,i)
                raise Exception(&#34;NODE NOT FOUND&#34;)

    self.circuitgraph.add_node(&#34;module#&#34;+self.module_name, type=&#34;module&#34;)
    for i in self.io[&#34;outputs&#34;]:
        tmpi=self.io[&#34;outputs&#34;][i]
        if(tmpi[&#39;bits&#39;]==1):
            self.circuitgraph.add_edge(i,&#34;module#&#34;+self.module_name)
        else:
            for k in range(tmpi[&#39;startbit&#39;],tmpi[&#34;endbit&#34;]+1):
                self.circuitgraph.add_edge(i+f&#34;[{k}]&#34;,&#34;module#&#34;+self.module_name)

    for i in self.io[&#34;inputs&#34;]:
        tmpi=self.io[&#34;inputs&#34;][i]
        if(tmpi[&#39;bits&#39;]==1):
            self.circuitgraph.add_edge(&#34;module#&#34;+self.module_name,i)
        else:
            for k in range(tmpi[&#39;startbit&#39;],tmpi[&#34;endbit&#34;]+1):
                self.circuitgraph.add_edge(&#34;module#&#34;+self.module_name,i+f&#34;[{k}]&#34;)
    self.change_flag=0</code></pre>
</details>
</dd>
<dt id="src.Netlist.AST.module.nodeio"><code class="name flex">
<span>def <span class="ident">nodeio</span></span>(<span>self, Node) >None</span>
</code></dt>
<dd>
<div class="desc"><p>Print the outputs and inputs of a node in the circuit graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>Node</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nodeio(self,Node)-&gt;None:
    &#34;&#34;&#34;
    Print the outputs and inputs of a node in the circuit graph.
    
    Args:
        Node (str): The name of the node.
    &#34;&#34;&#34;
    print(&#34;Node outputs = &#34;,list(self.circuitgraph.successors(Node))) 
    print(&#34;Node inputs = &#34;,list(self.circuitgraph.predecessors(Node)))    </code></pre>
</details>
</dd>
<dt id="src.Netlist.AST.module.save_graph"><code class="name flex">
<span>def <span class="ident">save_graph</span></span>(<span>self, svg=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the circuit graph as an SVG image.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>svg</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to save the graph as an SVG image (default: False).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_graph(self,svg=False):
    &#34;&#34;&#34;
    Save the circuit graph as an SVG image.
    
    Args:
        svg (bool): Whether to save the graph as an SVG image (default: False).
    &#34;&#34;&#34;
    utils.save_graph(self.circuitgraph,svg)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.Netlist" href="index.html">src.Netlist</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.Netlist.AST.AST" href="#src.Netlist.AST.AST">AST</a></code></h4>
<ul class="">
<li><code><a title="src.Netlist.AST.AST.gen_LLFile" href="#src.Netlist.AST.AST.gen_LLFile">gen_LLFile</a></code></li>
<li><code><a title="src.Netlist.AST.AST.gen_graph_links" href="#src.Netlist.AST.AST.gen_graph_links">gen_graph_links</a></code></li>
<li><code><a title="src.Netlist.AST.AST.gen_results" href="#src.Netlist.AST.AST.gen_results">gen_results</a></code></li>
<li><code><a title="src.Netlist.AST.AST.gen_verification_files" href="#src.Netlist.AST.AST.gen_verification_files">gen_verification_files</a></code></li>
<li><code><a title="src.Netlist.AST.AST.read_LLFile" href="#src.Netlist.AST.AST.read_LLFile">read_LLFile</a></code></li>
<li><code><a title="src.Netlist.AST.AST.sub_modules_data" href="#src.Netlist.AST.AST.sub_modules_data">sub_modules_data</a></code></li>
<li><code><a title="src.Netlist.AST.AST.update_LLverilog" href="#src.Netlist.AST.AST.update_LLverilog">update_LLverilog</a></code></li>
<li><code><a title="src.Netlist.AST.AST.writeLLFile" href="#src.Netlist.AST.AST.writeLLFile">writeLLFile</a></code></li>
<li><code><a title="src.Netlist.AST.AST.write_Verilog_File" href="#src.Netlist.AST.AST.write_Verilog_File">write_Verilog_File</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.Netlist.AST.module" href="#src.Netlist.AST.module">module</a></code></h4>
<ul class="">
<li><code><a title="src.Netlist.AST.module.bin_graph" href="#src.Netlist.AST.module.bin_graph">bin_graph</a></code></li>
<li><code><a title="src.Netlist.AST.module.gen_LL_verilog" href="#src.Netlist.AST.module.gen_LL_verilog">gen_LL_verilog</a></code></li>
<li><code><a title="src.Netlist.AST.module.gen_graph" href="#src.Netlist.AST.module.gen_graph">gen_graph</a></code></li>
<li><code><a title="src.Netlist.AST.module.nodeio" href="#src.Netlist.AST.module.nodeio">nodeio</a></code></li>
<li><code><a title="src.Netlist.AST.module.save_graph" href="#src.Netlist.AST.module.save_graph">save_graph</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>