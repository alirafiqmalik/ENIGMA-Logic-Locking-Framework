<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.Locking.PostSAT API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.Locking.PostSAT</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import src.utils as utils
import random
import re

####################################################################################################################################
####################################################################################################################################

# &#34;module {name} (inputs, keys, Q);\nparameter n={ic};input [n-1:0] inputs;input [n-1:0] keys;output Q;reg key = {ic}&#39;d{key};assign Q = (ckt_output ^ ((inputs == keys) &amp; (inputs != key)));endmodule&#34;

def gencc_SarLock(modulename, inputs,key):
    codestr=&#34;module {name} (inputs, keys, Q);parameter n={ic};input [n-1:0] inputs;input [n-1:0] keys;output Q;assign Q = (((inputs == keys) &amp; (inputs != {ic}&#39;d{key})));endmodule&#34;
    ic = len(inputs)
    comver = codestr.format(name=modulename,ic=ic,key=key)
    port=modulename+&#34; {init} ({portnodes}, {KEY}, {Q});&#34; 
    return re.sub(&#34;;&#34;, &#34;;\n&#34;, comver),port


####################################################################################################################################
####################################################################################################################################


def gencc_AntiSAT(modulename, inputs):
    codestr=&#34;module {name} (A,KEY,Q); parameter n={ic}; input [n-1:0] A; input [2*n-1:0] KEY; output Q; wire Q1,Q2; wire [n-1:0] X_xor1; wire [n-1:0] X_xor2; reg [n-1:0] Q1_reg; reg [n-1:0] Q2_reg; assign X_xor1 = A ^ KEY[n-1:0]; assign X_xor2 = A ^ KEY[2*n-1:n]; integer k; always @(*) begin Q1 = 1; Q2 = 1; for(k=0;k&lt;n-1;k=k+1) begin if(X_xor1[k]==0) Q1=0; if(X_xor2[k]==0) Q2=0; end end assign Q1_reg = {{Q1_reg[n-2:0], Q1}}; assign Q2_reg = {{Q2_reg[n-2:0], Q2\}}; assign Q = Q1_reg[n-1] &amp; (~Q2_reg[n-1]);endmodule&#34;
    # codestr=&#34;module {name} (A,KEY,Q);parameter n={ic};input [n-1:0] A;input [2*n-1:0] KEY;output Q;wire Q1,Q2;g_block g(A,KEY[n-1:0],Q1);g_block gc(A,KEY[2*n-1:n],Q2);assign Q = Q1 &amp; (~Q2);endmodule&#34;
    # submodule=&#34;module g_block(X,KEY_X,Q);parameter n={ic};input [n-1:0]X;input [n-1:0]KEY_X;output reg Q;wire [n-1:0]X_xor;assign X_xor=X^KEY_X;integer k;always@(*)begin Q=1;for(k=0;k&lt;n-1;k=k+1)begin if(X_xor[k]==0) Q=0;end end endmodule&#34;
    ic = len(inputs)
    
    comver = codestr.format(name=modulename,ic=ic)
    port=modulename+&#34; {init} ({portnodes}, {KEY}, {Q});&#34; 
    

    return re.sub(&#34;;&#34;, &#34;;\n&#34;, comver),port


####################################################################################################################################
####################################################################################################################################

def gencc(modulename, inputs, key):
    ic = len(inputs)
    portnodes, inputnodes,_ = utils.io_port(inputs)
    if (key == None):
        comver = &#34;module &#34;+modulename+&#34;(&#34;+portnodes+&#34;,KEY,Q);&#34; + inputnodes + &#34;input [&#34;+str(ic-1)+&#34;:0]KEY;&#34; + &#34;wire [&#34;+str(
            ic-1)+&#34;:0]A;assign A={&#34;+portnodes+&#34;};output reg Q;always@(*)begin if(A==KEY)Q=1;else Q=0;end endmodule&#34;
        port=modulename+&#34; {init} ({portnodes}, {KEY}, {Q});&#34; 
             
    else:
        comver = &#34;module &#34;+modulename+&#34;(&#34;+portnodes+&#34;,Q);&#34; + inputnodes + &#34;wire [&#34;+str(
            ic-1)+&#34;:0]A;assign A={&#34;+portnodes+&#34;};output reg Q;always@(*)begin if(A==&#34;+str(ic)+&#34;&#39;d&#34;+str(key)+&#34;)Q=1;else Q=0;end endmodule&#34;
        port=modulename+&#34; {init} ({portnodes}, {Q});&#34; 
        

    return re.sub(&#34;;&#34;, &#34;;\n&#34;, comver), portnodes,port


####################################################################################################################################
####################################################################################################################################


def hammingcc(modulename, inputs, h, key=None):
    ic = len(inputs)
    portnodes, inputnodes,_ = utils.io_port(inputs)
    # print(&#34;HERE &#34;,utils.io_port(inputs))
    if (key == None):
        comver = &#34;module &#34;+modulename+&#34;(&#34;+portnodes+&#34;,KEY,Q);&#34; + inputnodes + &#34;input [&#34;+str(ic-1)+&#34;:0]KEY;wire [&#34;+str(
            ic-1)+&#34;:0]A;assign A={&#34;+portnodes+&#34;};output reg Q;integer Qr,count,i;always@(*)begin Qr=KEY^A;count=0;for(i=0;i&lt;&#34;+str(ic)+&#34;;i=i+1)begin if(Qr[i]) count=count+1;end if(count==&#34;+str(h)+&#34;)Q=1;else Q=0;end endmodule&#34;
        port=modulename+&#34; {init} (&#34;+portnodes+&#34;,{key},{Q});&#34;
    else:
        comver = &#34;module &#34;+modulename+&#34;(&#34;+portnodes+&#34;,Q);&#34; + inputnodes + &#34; wire [&#34;+str(ic-1)+&#34;:0]A;assign A={&#34;+portnodes+&#34;};output reg Q;integer Qr,count,i;always@(*)begin Qr=&#34;+str(
            ic)+&#34;&#39;d&#34;+str(key)+&#34;^A;count=0;for(i=0;i&lt;&#34;+str(ic)+&#34;;i=i+1)begin if(Qr[i]) count=count+1;end if(count==&#34;+str(h)+&#34;)Q=1;else Q=0;end endmodule&#34;
        port=modulename+&#34; {init} (&#34;+portnodes+&#34;,{Q});&#34;
    return re.sub(&#34;;&#34;, &#34;;\n&#34;, comver), portnodes,port









class PostSAT:
    def __init__(self,module) -&gt; None:
        self.module=module
        self.circuitgraph=module.circuitgraph

    def set_key(self,bits:int=128,inputs:list=None,outputs:list=None):
        # self.input_count={i:self.module.io[&#39;inputs&#39;][i][&#39;bits&#39;] for i in self.module.io[&#39;inputs&#39;]}

        self.inputs={i:self.module.io[&#39;inputs&#39;][i] for i in self.module.io[&#39;inputs&#39;]}
        utils.remove_key(self.inputs,&#34;lockingkeyinput&#34;)
        utils.remove_key(self.inputs,self.module.io[&#34;Clock_pins&#34;])

        if(inputs==None):
            self.key_inputs,returned_bits=utils.rand_selection(self.inputs,&#39;bits&#39;,bits)
            bits=returned_bits
            self.key=utils.randKey(bits, seed=None)
        else:     
            # self.key_inputs=inputs
            self.key_inputs={i:self.module.io[&#39;inputs&#39;][i] for i in inputs}
            bits=len(self.key_inputs)
            self.key=utils.randKey(bits, seed=None)

        # self.keystart=len(self.module.bitkey)

        self.bits=bits
        self.intkey,self.bitkey=utils.randKey(bits)
        self.module.bitkey=self.bitkey+self.module.bitkey

        if(outputs==None):
            self.key_outputs={i:self.module.io[&#39;outputs&#39;][i] for i in self.module.io[&#39;outputs&#39;]}
        else:     
            # self.key_outputs=outputs
            self.key_outputs={i:self.module.io[&#39;outputs&#39;][i] for i in outputs}


    def AntiSAT(self):
        no_of_init=len(self.module.linkages)
        modulename=f&#34;antisat_{no_of_init}&#34;
        nodes,ic=utils.node_to_txt(self.key_inputs,mode=&#34;input&#34;,return_bits=True)
        initname=f&#34;{modulename}_init{self.module.module_name}_{no_of_init}&#34;

        c=len(self.module.io[&#39;wires&#39;])

        outQ=f&#34;Q_int_{c}&#34;

        lockinginputs_count=len(self.module.lockingdata[&#34;inputs&#34;])
        a=lockinginputs_count+ic-1
        b=lockinginputs_count
        links=[]
        port=&#34;&#34;
        portnodes=&#34;&#34;
        for i in self.key_inputs:
            links.append((i,i,&#34;I&#34;))
            port+=f&#34;.{i}({i}), &#34;
            portnodes+=f&#34;{i}, &#34;
        portnodes=portnodes[:-2]
        port+=f&#34;.KEY(lockingkeyinput[{a}:{b}]), &#34;
        port+=f&#34;.Q({outQ})&#34;

        links.append((&#34;KEY&#34;,f&#34;lockingkeyinput[{a}:{b}]&#34;,&#34;I&#34;))
        links.append((&#34;Q&#34;,outQ,&#34;O&#34;))

        tmp,port_null=gencc_AntiSAT(modulename, self.inputs)
        # tmp=f&#34;module {modulename}({portnodes}, KEY, Q);\n{nodes}input [{ic-1}:0] KEY;\nwire [{ic-1}:0] A;\nassign A={{{portnodes}}};\noutput reg Q;\nalways@(*)begin \nif(A==KEY)Q=1;\nelse Q=0;\nend \nendmodule&#34;

        self.module.io[&#39;wires&#39;][outQ]=utils.connector(1,0,0)

        self.module.linkages[initname]={&#34;module_name&#34;: modulename,&#34;links&#34;:links,&#34;port&#34;:port,&#34;code&#34;:tmp}
        print(utils.connector(a+1,0,a),utils.connector(a+1,0,a))
        if(&#34;lockingkeyinput&#34; not in self.module.io[&#39;inputs&#39;]):
            self.module.io[&#39;inputs&#39;][&#34;lockingkeyinput&#34;]=utils.connector(a+1,0,a)
            self.module.io[&#34;input_ports&#34;]+=&#34;lockingkeyinput,&#34;
        else:
            self.module.io[&#39;inputs&#39;][&#34;lockingkeyinput&#34;]=utils.connector(a+1,0,a)
        

        for i,bitval in enumerate(range(b,a+1)):
            keygate_input_name=f&#34;lockingkeyinput[{bitval}]&#34;
            bit=self.bitkey[self.bits-i-1]
            # print(self.bits-i-1,self.bitkey[self.bits-i-1])
            # print(bit,key_bit-1-i)
            # bit=&#34;0&#34; if new_gatetype==&#34;XOR&#34; else &#34;1&#34; 
            # self.keyint,self.bitkey=randKey(self.keycount)
            self.module.lockingdata[&#34;inputs&#34;].append((keygate_input_name,bit))

    def Sarlock(self):
        no_of_init=len(self.module.linkages)
        modulename=f&#34;Sarlock_{no_of_init}&#34;
        nodes,ic=utils.node_to_txt(self.key_inputs,mode=&#34;input&#34;,return_bits=True)
        initname=f&#34;{modulename}_init{self.module.module_name}_{no_of_init}&#34;

        c=len(self.module.io[&#39;wires&#39;])

        outQ=f&#34;Q_int_{c}&#34;

        lockinginputs_count=len(self.module.lockingdata[&#34;inputs&#34;])
        a=lockinginputs_count+ic-1
        b=lockinginputs_count
        links=[]
        port=&#34;&#34;
        portnodes=&#34;&#34;
        for i in self.key_inputs:
            links.append((i,i,&#34;I&#34;))
            port+=f&#34;.{i}({i}), &#34;
            portnodes+=f&#34;{i}, &#34;
        portnodes=portnodes[:-2]
        port+=f&#34;.KEY(lockingkeyinput[{a}:{b}]), &#34;
        port+=f&#34;.Q({outQ})&#34;

        links.append((&#34;KEY&#34;,f&#34;lockingkeyinput[{b}:{a}]&#34;,&#34;I&#34;))
        links.append((&#34;Q&#34;,outQ,&#34;O&#34;))

        # tmp,port_null=gencc_SarLock(modulename, self.inputs, self.bitkey)
        # tmp=f&#34;module {modulename}({portnodes}, KEY, Q);{nodes}input [{ic-1}:0] KEY;\nwire [{ic-1}:0] A;\nassign A={{{portnodes}}};\noutput reg Q;\nalways@(*)begin \nif(A==KEY)Q=1;\nelse Q=0;\nend \nendmodule&#34;
        # tmp=f&#34;module {modulename}({portnodes}, KEY, Q);\n{nodes}input [{ic-1}:0] KEY;\nwire [{ic-1}:0] A;\nassign A={{{portnodes}}};\noutput Q;\nassign Q = (((A == KEY) &amp; (A != {ic}&#39;b{self.bitkey})));\nendmodule&#34;
        tmp=f&#34;module {modulename}({portnodes}, KEY, Q);{nodes} input [{ic-1}:0] KEY;wire [{ic-1}:0] A;assign A={{{portnodes}}};output Q;assign Q=((A == KEY) &amp; (A !={ic}&#39;b{self.bitkey}));endmodule&#34;



        self.module.io[&#39;wires&#39;][outQ]=utils.connector(1,0,0)

        self.module.linkages[initname]={&#34;module_name&#34;: modulename,&#34;links&#34;:links,&#34;port&#34;:port,&#34;code&#34;:tmp}

        if(&#34;lockingkeyinput&#34; not in self.module.io[&#39;inputs&#39;]):
            self.module.io[&#39;inputs&#39;][&#34;lockingkeyinput&#34;]=utils.connector(a+1,0,a)
            self.module.io[&#34;input_ports&#34;]+=&#34;lockingkeyinput,&#34;
        else:
            self.module.io[&#39;inputs&#39;][&#34;lockingkeyinput&#34;]=utils.connector(a+1,0,a)
        
        for i,bitval in enumerate(range(b,a+1)):
            keygate_input_name=f&#34;lockingkeyinput[{bitval}]&#34;
            bit=self.bitkey[self.bits-i-1]
            self.module.lockingdata[&#34;inputs&#34;].append((keygate_input_name,bit))
        
        # print(self.key_outputs.keys())
        for output in self.key_outputs:
            gatetype=&#34;XOR&#34;
            output_data=self.key_outputs[output]
            if(output_data[&#39;bits&#39;]!=1):
                start=output_data[&#34;startbit&#34;]
                end=output_data[&#34;endbit&#34;]
                cal_output_i=lambda output,bit_i:f&#34;{output}[{bit_i}]&#34;
            else:
                start=end=1
                cal_output_i=lambda output,_:f&#34;{output}&#34;
            
            for bit_i in range(start,end+1):
                output_i=cal_output_i(output,bit_i)
                keygatecount=len(self.module.gates)
                wirecount=len(self.module.io[&#39;wires&#39;])

                # print(output_i,bit_i)


                # print(&#34;output  &#34;,output_i)
                pred_i=list(self.circuitgraph.predecessors(output_i))
                if(pred_i==[]):
                    continue
                else:
                    # print(&#34;HERE  &#34;,pred_i)
                    pred_i=pred_i[0]

                connection_gate=f&#34;connection_gate_Sarlock_{output}_{bit_i}_{keygatecount}&#34;
                connection_wire=f&#34;connection_wire_Sarlock_{output}_{bit_i}_{wirecount}&#34;


                self.circuitgraph.remove_edge(pred_i, output_i)

                self.circuitgraph.add_node(connection_gate,type=&#34;gate&#34;,logic=gatetype)
                self.circuitgraph.add_node(connection_wire,type=&#34;wire&#34;,logic=connection_wire)
                
                self.circuitgraph.add_edge(pred_i, connection_wire)
                self.circuitgraph.add_edge(connection_wire, connection_gate)
                self.circuitgraph.add_edge(outQ, connection_gate)
                self.circuitgraph.add_edge(connection_gate, output_i)

                
                # pred_i, output_i
                Na=self.circuitgraph.nodes[pred_i]
                # Nb=self.circuitgraph.nodes[NodeB]
                # print(NodeA,Na)
                if(Na[&#39;type&#39;]==&#39;gate&#39;):
                    self.module.gates[Na[&#39;logic&#39;]][pred_i][&#39;outputs&#39;]=connection_wire
                elif(&#39;DFF&#39; in Na[&#39;type&#39;].upper()):
                    # print(&#34;here &#34;,Na,pred_i)
                    # print(self.module.FF_tech[Na[&#39;type&#39;]][pred_i])
                    self.module.FF_tech[Na[&#39;type&#39;]][pred_i][&#39;outputs&#39;]=connection_wire
                    # print(self.module.FF_tech[Na[&#39;type&#39;]][pred_i])
                else:
                    raise Exception(&#34;NOT A GATE WHYYYYYY???????????&#34;)
                

                self.module.io[&#39;wires&#39;][connection_wire]=utils.connector(1,0,0)

                if(gatetype not in self.module.gates.keys()):
                    self.module.gates[gatetype]={}
                    
                self.module.gates[gatetype][connection_gate]={&#34;inputs&#34;: [connection_wire,outQ] ,&#34;outputs&#34;: output_i}
            
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.Locking.PostSAT.gencc"><code class="name flex">
<span>def <span class="ident">gencc</span></span>(<span>modulename, inputs, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gencc(modulename, inputs, key):
    ic = len(inputs)
    portnodes, inputnodes,_ = utils.io_port(inputs)
    if (key == None):
        comver = &#34;module &#34;+modulename+&#34;(&#34;+portnodes+&#34;,KEY,Q);&#34; + inputnodes + &#34;input [&#34;+str(ic-1)+&#34;:0]KEY;&#34; + &#34;wire [&#34;+str(
            ic-1)+&#34;:0]A;assign A={&#34;+portnodes+&#34;};output reg Q;always@(*)begin if(A==KEY)Q=1;else Q=0;end endmodule&#34;
        port=modulename+&#34; {init} ({portnodes}, {KEY}, {Q});&#34; 
             
    else:
        comver = &#34;module &#34;+modulename+&#34;(&#34;+portnodes+&#34;,Q);&#34; + inputnodes + &#34;wire [&#34;+str(
            ic-1)+&#34;:0]A;assign A={&#34;+portnodes+&#34;};output reg Q;always@(*)begin if(A==&#34;+str(ic)+&#34;&#39;d&#34;+str(key)+&#34;)Q=1;else Q=0;end endmodule&#34;
        port=modulename+&#34; {init} ({portnodes}, {Q});&#34; 
        

    return re.sub(&#34;;&#34;, &#34;;\n&#34;, comver), portnodes,port</code></pre>
</details>
</dd>
<dt id="src.Locking.PostSAT.gencc_AntiSAT"><code class="name flex">
<span>def <span class="ident">gencc_AntiSAT</span></span>(<span>modulename, inputs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gencc_AntiSAT(modulename, inputs):
    codestr=&#34;module {name} (A,KEY,Q); parameter n={ic}; input [n-1:0] A; input [2*n-1:0] KEY; output Q; wire Q1,Q2; wire [n-1:0] X_xor1; wire [n-1:0] X_xor2; reg [n-1:0] Q1_reg; reg [n-1:0] Q2_reg; assign X_xor1 = A ^ KEY[n-1:0]; assign X_xor2 = A ^ KEY[2*n-1:n]; integer k; always @(*) begin Q1 = 1; Q2 = 1; for(k=0;k&lt;n-1;k=k+1) begin if(X_xor1[k]==0) Q1=0; if(X_xor2[k]==0) Q2=0; end end assign Q1_reg = {{Q1_reg[n-2:0], Q1}}; assign Q2_reg = {{Q2_reg[n-2:0], Q2\}}; assign Q = Q1_reg[n-1] &amp; (~Q2_reg[n-1]);endmodule&#34;
    # codestr=&#34;module {name} (A,KEY,Q);parameter n={ic};input [n-1:0] A;input [2*n-1:0] KEY;output Q;wire Q1,Q2;g_block g(A,KEY[n-1:0],Q1);g_block gc(A,KEY[2*n-1:n],Q2);assign Q = Q1 &amp; (~Q2);endmodule&#34;
    # submodule=&#34;module g_block(X,KEY_X,Q);parameter n={ic};input [n-1:0]X;input [n-1:0]KEY_X;output reg Q;wire [n-1:0]X_xor;assign X_xor=X^KEY_X;integer k;always@(*)begin Q=1;for(k=0;k&lt;n-1;k=k+1)begin if(X_xor[k]==0) Q=0;end end endmodule&#34;
    ic = len(inputs)
    
    comver = codestr.format(name=modulename,ic=ic)
    port=modulename+&#34; {init} ({portnodes}, {KEY}, {Q});&#34; 
    

    return re.sub(&#34;;&#34;, &#34;;\n&#34;, comver),port</code></pre>
</details>
</dd>
<dt id="src.Locking.PostSAT.gencc_SarLock"><code class="name flex">
<span>def <span class="ident">gencc_SarLock</span></span>(<span>modulename, inputs, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gencc_SarLock(modulename, inputs,key):
    codestr=&#34;module {name} (inputs, keys, Q);parameter n={ic};input [n-1:0] inputs;input [n-1:0] keys;output Q;assign Q = (((inputs == keys) &amp; (inputs != {ic}&#39;d{key})));endmodule&#34;
    ic = len(inputs)
    comver = codestr.format(name=modulename,ic=ic,key=key)
    port=modulename+&#34; {init} ({portnodes}, {KEY}, {Q});&#34; 
    return re.sub(&#34;;&#34;, &#34;;\n&#34;, comver),port</code></pre>
</details>
</dd>
<dt id="src.Locking.PostSAT.hammingcc"><code class="name flex">
<span>def <span class="ident">hammingcc</span></span>(<span>modulename, inputs, h, key=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hammingcc(modulename, inputs, h, key=None):
    ic = len(inputs)
    portnodes, inputnodes,_ = utils.io_port(inputs)
    # print(&#34;HERE &#34;,utils.io_port(inputs))
    if (key == None):
        comver = &#34;module &#34;+modulename+&#34;(&#34;+portnodes+&#34;,KEY,Q);&#34; + inputnodes + &#34;input [&#34;+str(ic-1)+&#34;:0]KEY;wire [&#34;+str(
            ic-1)+&#34;:0]A;assign A={&#34;+portnodes+&#34;};output reg Q;integer Qr,count,i;always@(*)begin Qr=KEY^A;count=0;for(i=0;i&lt;&#34;+str(ic)+&#34;;i=i+1)begin if(Qr[i]) count=count+1;end if(count==&#34;+str(h)+&#34;)Q=1;else Q=0;end endmodule&#34;
        port=modulename+&#34; {init} (&#34;+portnodes+&#34;,{key},{Q});&#34;
    else:
        comver = &#34;module &#34;+modulename+&#34;(&#34;+portnodes+&#34;,Q);&#34; + inputnodes + &#34; wire [&#34;+str(ic-1)+&#34;:0]A;assign A={&#34;+portnodes+&#34;};output reg Q;integer Qr,count,i;always@(*)begin Qr=&#34;+str(
            ic)+&#34;&#39;d&#34;+str(key)+&#34;^A;count=0;for(i=0;i&lt;&#34;+str(ic)+&#34;;i=i+1)begin if(Qr[i]) count=count+1;end if(count==&#34;+str(h)+&#34;)Q=1;else Q=0;end endmodule&#34;
        port=modulename+&#34; {init} (&#34;+portnodes+&#34;,{Q});&#34;
    return re.sub(&#34;;&#34;, &#34;;\n&#34;, comver), portnodes,port</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.Locking.PostSAT.PostSAT"><code class="flex name class">
<span>class <span class="ident">PostSAT</span></span>
<span>(</span><span>module)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PostSAT:
    def __init__(self,module) -&gt; None:
        self.module=module
        self.circuitgraph=module.circuitgraph

    def set_key(self,bits:int=128,inputs:list=None,outputs:list=None):
        # self.input_count={i:self.module.io[&#39;inputs&#39;][i][&#39;bits&#39;] for i in self.module.io[&#39;inputs&#39;]}

        self.inputs={i:self.module.io[&#39;inputs&#39;][i] for i in self.module.io[&#39;inputs&#39;]}
        utils.remove_key(self.inputs,&#34;lockingkeyinput&#34;)
        utils.remove_key(self.inputs,self.module.io[&#34;Clock_pins&#34;])

        if(inputs==None):
            self.key_inputs,returned_bits=utils.rand_selection(self.inputs,&#39;bits&#39;,bits)
            bits=returned_bits
            self.key=utils.randKey(bits, seed=None)
        else:     
            # self.key_inputs=inputs
            self.key_inputs={i:self.module.io[&#39;inputs&#39;][i] for i in inputs}
            bits=len(self.key_inputs)
            self.key=utils.randKey(bits, seed=None)

        # self.keystart=len(self.module.bitkey)

        self.bits=bits
        self.intkey,self.bitkey=utils.randKey(bits)
        self.module.bitkey=self.bitkey+self.module.bitkey

        if(outputs==None):
            self.key_outputs={i:self.module.io[&#39;outputs&#39;][i] for i in self.module.io[&#39;outputs&#39;]}
        else:     
            # self.key_outputs=outputs
            self.key_outputs={i:self.module.io[&#39;outputs&#39;][i] for i in outputs}


    def AntiSAT(self):
        no_of_init=len(self.module.linkages)
        modulename=f&#34;antisat_{no_of_init}&#34;
        nodes,ic=utils.node_to_txt(self.key_inputs,mode=&#34;input&#34;,return_bits=True)
        initname=f&#34;{modulename}_init{self.module.module_name}_{no_of_init}&#34;

        c=len(self.module.io[&#39;wires&#39;])

        outQ=f&#34;Q_int_{c}&#34;

        lockinginputs_count=len(self.module.lockingdata[&#34;inputs&#34;])
        a=lockinginputs_count+ic-1
        b=lockinginputs_count
        links=[]
        port=&#34;&#34;
        portnodes=&#34;&#34;
        for i in self.key_inputs:
            links.append((i,i,&#34;I&#34;))
            port+=f&#34;.{i}({i}), &#34;
            portnodes+=f&#34;{i}, &#34;
        portnodes=portnodes[:-2]
        port+=f&#34;.KEY(lockingkeyinput[{a}:{b}]), &#34;
        port+=f&#34;.Q({outQ})&#34;

        links.append((&#34;KEY&#34;,f&#34;lockingkeyinput[{a}:{b}]&#34;,&#34;I&#34;))
        links.append((&#34;Q&#34;,outQ,&#34;O&#34;))

        tmp,port_null=gencc_AntiSAT(modulename, self.inputs)
        # tmp=f&#34;module {modulename}({portnodes}, KEY, Q);\n{nodes}input [{ic-1}:0] KEY;\nwire [{ic-1}:0] A;\nassign A={{{portnodes}}};\noutput reg Q;\nalways@(*)begin \nif(A==KEY)Q=1;\nelse Q=0;\nend \nendmodule&#34;

        self.module.io[&#39;wires&#39;][outQ]=utils.connector(1,0,0)

        self.module.linkages[initname]={&#34;module_name&#34;: modulename,&#34;links&#34;:links,&#34;port&#34;:port,&#34;code&#34;:tmp}
        print(utils.connector(a+1,0,a),utils.connector(a+1,0,a))
        if(&#34;lockingkeyinput&#34; not in self.module.io[&#39;inputs&#39;]):
            self.module.io[&#39;inputs&#39;][&#34;lockingkeyinput&#34;]=utils.connector(a+1,0,a)
            self.module.io[&#34;input_ports&#34;]+=&#34;lockingkeyinput,&#34;
        else:
            self.module.io[&#39;inputs&#39;][&#34;lockingkeyinput&#34;]=utils.connector(a+1,0,a)
        

        for i,bitval in enumerate(range(b,a+1)):
            keygate_input_name=f&#34;lockingkeyinput[{bitval}]&#34;
            bit=self.bitkey[self.bits-i-1]
            # print(self.bits-i-1,self.bitkey[self.bits-i-1])
            # print(bit,key_bit-1-i)
            # bit=&#34;0&#34; if new_gatetype==&#34;XOR&#34; else &#34;1&#34; 
            # self.keyint,self.bitkey=randKey(self.keycount)
            self.module.lockingdata[&#34;inputs&#34;].append((keygate_input_name,bit))

    def Sarlock(self):
        no_of_init=len(self.module.linkages)
        modulename=f&#34;Sarlock_{no_of_init}&#34;
        nodes,ic=utils.node_to_txt(self.key_inputs,mode=&#34;input&#34;,return_bits=True)
        initname=f&#34;{modulename}_init{self.module.module_name}_{no_of_init}&#34;

        c=len(self.module.io[&#39;wires&#39;])

        outQ=f&#34;Q_int_{c}&#34;

        lockinginputs_count=len(self.module.lockingdata[&#34;inputs&#34;])
        a=lockinginputs_count+ic-1
        b=lockinginputs_count
        links=[]
        port=&#34;&#34;
        portnodes=&#34;&#34;
        for i in self.key_inputs:
            links.append((i,i,&#34;I&#34;))
            port+=f&#34;.{i}({i}), &#34;
            portnodes+=f&#34;{i}, &#34;
        portnodes=portnodes[:-2]
        port+=f&#34;.KEY(lockingkeyinput[{a}:{b}]), &#34;
        port+=f&#34;.Q({outQ})&#34;

        links.append((&#34;KEY&#34;,f&#34;lockingkeyinput[{b}:{a}]&#34;,&#34;I&#34;))
        links.append((&#34;Q&#34;,outQ,&#34;O&#34;))

        # tmp,port_null=gencc_SarLock(modulename, self.inputs, self.bitkey)
        # tmp=f&#34;module {modulename}({portnodes}, KEY, Q);{nodes}input [{ic-1}:0] KEY;\nwire [{ic-1}:0] A;\nassign A={{{portnodes}}};\noutput reg Q;\nalways@(*)begin \nif(A==KEY)Q=1;\nelse Q=0;\nend \nendmodule&#34;
        # tmp=f&#34;module {modulename}({portnodes}, KEY, Q);\n{nodes}input [{ic-1}:0] KEY;\nwire [{ic-1}:0] A;\nassign A={{{portnodes}}};\noutput Q;\nassign Q = (((A == KEY) &amp; (A != {ic}&#39;b{self.bitkey})));\nendmodule&#34;
        tmp=f&#34;module {modulename}({portnodes}, KEY, Q);{nodes} input [{ic-1}:0] KEY;wire [{ic-1}:0] A;assign A={{{portnodes}}};output Q;assign Q=((A == KEY) &amp; (A !={ic}&#39;b{self.bitkey}));endmodule&#34;



        self.module.io[&#39;wires&#39;][outQ]=utils.connector(1,0,0)

        self.module.linkages[initname]={&#34;module_name&#34;: modulename,&#34;links&#34;:links,&#34;port&#34;:port,&#34;code&#34;:tmp}

        if(&#34;lockingkeyinput&#34; not in self.module.io[&#39;inputs&#39;]):
            self.module.io[&#39;inputs&#39;][&#34;lockingkeyinput&#34;]=utils.connector(a+1,0,a)
            self.module.io[&#34;input_ports&#34;]+=&#34;lockingkeyinput,&#34;
        else:
            self.module.io[&#39;inputs&#39;][&#34;lockingkeyinput&#34;]=utils.connector(a+1,0,a)
        
        for i,bitval in enumerate(range(b,a+1)):
            keygate_input_name=f&#34;lockingkeyinput[{bitval}]&#34;
            bit=self.bitkey[self.bits-i-1]
            self.module.lockingdata[&#34;inputs&#34;].append((keygate_input_name,bit))
        
        # print(self.key_outputs.keys())
        for output in self.key_outputs:
            gatetype=&#34;XOR&#34;
            output_data=self.key_outputs[output]
            if(output_data[&#39;bits&#39;]!=1):
                start=output_data[&#34;startbit&#34;]
                end=output_data[&#34;endbit&#34;]
                cal_output_i=lambda output,bit_i:f&#34;{output}[{bit_i}]&#34;
            else:
                start=end=1
                cal_output_i=lambda output,_:f&#34;{output}&#34;
            
            for bit_i in range(start,end+1):
                output_i=cal_output_i(output,bit_i)
                keygatecount=len(self.module.gates)
                wirecount=len(self.module.io[&#39;wires&#39;])

                # print(output_i,bit_i)


                # print(&#34;output  &#34;,output_i)
                pred_i=list(self.circuitgraph.predecessors(output_i))
                if(pred_i==[]):
                    continue
                else:
                    # print(&#34;HERE  &#34;,pred_i)
                    pred_i=pred_i[0]

                connection_gate=f&#34;connection_gate_Sarlock_{output}_{bit_i}_{keygatecount}&#34;
                connection_wire=f&#34;connection_wire_Sarlock_{output}_{bit_i}_{wirecount}&#34;


                self.circuitgraph.remove_edge(pred_i, output_i)

                self.circuitgraph.add_node(connection_gate,type=&#34;gate&#34;,logic=gatetype)
                self.circuitgraph.add_node(connection_wire,type=&#34;wire&#34;,logic=connection_wire)
                
                self.circuitgraph.add_edge(pred_i, connection_wire)
                self.circuitgraph.add_edge(connection_wire, connection_gate)
                self.circuitgraph.add_edge(outQ, connection_gate)
                self.circuitgraph.add_edge(connection_gate, output_i)

                
                # pred_i, output_i
                Na=self.circuitgraph.nodes[pred_i]
                # Nb=self.circuitgraph.nodes[NodeB]
                # print(NodeA,Na)
                if(Na[&#39;type&#39;]==&#39;gate&#39;):
                    self.module.gates[Na[&#39;logic&#39;]][pred_i][&#39;outputs&#39;]=connection_wire
                elif(&#39;DFF&#39; in Na[&#39;type&#39;].upper()):
                    # print(&#34;here &#34;,Na,pred_i)
                    # print(self.module.FF_tech[Na[&#39;type&#39;]][pred_i])
                    self.module.FF_tech[Na[&#39;type&#39;]][pred_i][&#39;outputs&#39;]=connection_wire
                    # print(self.module.FF_tech[Na[&#39;type&#39;]][pred_i])
                else:
                    raise Exception(&#34;NOT A GATE WHYYYYYY???????????&#34;)
                

                self.module.io[&#39;wires&#39;][connection_wire]=utils.connector(1,0,0)

                if(gatetype not in self.module.gates.keys()):
                    self.module.gates[gatetype]={}
                    
                self.module.gates[gatetype][connection_gate]={&#34;inputs&#34;: [connection_wire,outQ] ,&#34;outputs&#34;: output_i}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.Locking.PostSAT.PostSAT.AntiSAT"><code class="name flex">
<span>def <span class="ident">AntiSAT</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AntiSAT(self):
    no_of_init=len(self.module.linkages)
    modulename=f&#34;antisat_{no_of_init}&#34;
    nodes,ic=utils.node_to_txt(self.key_inputs,mode=&#34;input&#34;,return_bits=True)
    initname=f&#34;{modulename}_init{self.module.module_name}_{no_of_init}&#34;

    c=len(self.module.io[&#39;wires&#39;])

    outQ=f&#34;Q_int_{c}&#34;

    lockinginputs_count=len(self.module.lockingdata[&#34;inputs&#34;])
    a=lockinginputs_count+ic-1
    b=lockinginputs_count
    links=[]
    port=&#34;&#34;
    portnodes=&#34;&#34;
    for i in self.key_inputs:
        links.append((i,i,&#34;I&#34;))
        port+=f&#34;.{i}({i}), &#34;
        portnodes+=f&#34;{i}, &#34;
    portnodes=portnodes[:-2]
    port+=f&#34;.KEY(lockingkeyinput[{a}:{b}]), &#34;
    port+=f&#34;.Q({outQ})&#34;

    links.append((&#34;KEY&#34;,f&#34;lockingkeyinput[{a}:{b}]&#34;,&#34;I&#34;))
    links.append((&#34;Q&#34;,outQ,&#34;O&#34;))

    tmp,port_null=gencc_AntiSAT(modulename, self.inputs)
    # tmp=f&#34;module {modulename}({portnodes}, KEY, Q);\n{nodes}input [{ic-1}:0] KEY;\nwire [{ic-1}:0] A;\nassign A={{{portnodes}}};\noutput reg Q;\nalways@(*)begin \nif(A==KEY)Q=1;\nelse Q=0;\nend \nendmodule&#34;

    self.module.io[&#39;wires&#39;][outQ]=utils.connector(1,0,0)

    self.module.linkages[initname]={&#34;module_name&#34;: modulename,&#34;links&#34;:links,&#34;port&#34;:port,&#34;code&#34;:tmp}
    print(utils.connector(a+1,0,a),utils.connector(a+1,0,a))
    if(&#34;lockingkeyinput&#34; not in self.module.io[&#39;inputs&#39;]):
        self.module.io[&#39;inputs&#39;][&#34;lockingkeyinput&#34;]=utils.connector(a+1,0,a)
        self.module.io[&#34;input_ports&#34;]+=&#34;lockingkeyinput,&#34;
    else:
        self.module.io[&#39;inputs&#39;][&#34;lockingkeyinput&#34;]=utils.connector(a+1,0,a)
    

    for i,bitval in enumerate(range(b,a+1)):
        keygate_input_name=f&#34;lockingkeyinput[{bitval}]&#34;
        bit=self.bitkey[self.bits-i-1]
        # print(self.bits-i-1,self.bitkey[self.bits-i-1])
        # print(bit,key_bit-1-i)
        # bit=&#34;0&#34; if new_gatetype==&#34;XOR&#34; else &#34;1&#34; 
        # self.keyint,self.bitkey=randKey(self.keycount)
        self.module.lockingdata[&#34;inputs&#34;].append((keygate_input_name,bit))</code></pre>
</details>
</dd>
<dt id="src.Locking.PostSAT.PostSAT.Sarlock"><code class="name flex">
<span>def <span class="ident">Sarlock</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Sarlock(self):
    no_of_init=len(self.module.linkages)
    modulename=f&#34;Sarlock_{no_of_init}&#34;
    nodes,ic=utils.node_to_txt(self.key_inputs,mode=&#34;input&#34;,return_bits=True)
    initname=f&#34;{modulename}_init{self.module.module_name}_{no_of_init}&#34;

    c=len(self.module.io[&#39;wires&#39;])

    outQ=f&#34;Q_int_{c}&#34;

    lockinginputs_count=len(self.module.lockingdata[&#34;inputs&#34;])
    a=lockinginputs_count+ic-1
    b=lockinginputs_count
    links=[]
    port=&#34;&#34;
    portnodes=&#34;&#34;
    for i in self.key_inputs:
        links.append((i,i,&#34;I&#34;))
        port+=f&#34;.{i}({i}), &#34;
        portnodes+=f&#34;{i}, &#34;
    portnodes=portnodes[:-2]
    port+=f&#34;.KEY(lockingkeyinput[{a}:{b}]), &#34;
    port+=f&#34;.Q({outQ})&#34;

    links.append((&#34;KEY&#34;,f&#34;lockingkeyinput[{b}:{a}]&#34;,&#34;I&#34;))
    links.append((&#34;Q&#34;,outQ,&#34;O&#34;))

    # tmp,port_null=gencc_SarLock(modulename, self.inputs, self.bitkey)
    # tmp=f&#34;module {modulename}({portnodes}, KEY, Q);{nodes}input [{ic-1}:0] KEY;\nwire [{ic-1}:0] A;\nassign A={{{portnodes}}};\noutput reg Q;\nalways@(*)begin \nif(A==KEY)Q=1;\nelse Q=0;\nend \nendmodule&#34;
    # tmp=f&#34;module {modulename}({portnodes}, KEY, Q);\n{nodes}input [{ic-1}:0] KEY;\nwire [{ic-1}:0] A;\nassign A={{{portnodes}}};\noutput Q;\nassign Q = (((A == KEY) &amp; (A != {ic}&#39;b{self.bitkey})));\nendmodule&#34;
    tmp=f&#34;module {modulename}({portnodes}, KEY, Q);{nodes} input [{ic-1}:0] KEY;wire [{ic-1}:0] A;assign A={{{portnodes}}};output Q;assign Q=((A == KEY) &amp; (A !={ic}&#39;b{self.bitkey}));endmodule&#34;



    self.module.io[&#39;wires&#39;][outQ]=utils.connector(1,0,0)

    self.module.linkages[initname]={&#34;module_name&#34;: modulename,&#34;links&#34;:links,&#34;port&#34;:port,&#34;code&#34;:tmp}

    if(&#34;lockingkeyinput&#34; not in self.module.io[&#39;inputs&#39;]):
        self.module.io[&#39;inputs&#39;][&#34;lockingkeyinput&#34;]=utils.connector(a+1,0,a)
        self.module.io[&#34;input_ports&#34;]+=&#34;lockingkeyinput,&#34;
    else:
        self.module.io[&#39;inputs&#39;][&#34;lockingkeyinput&#34;]=utils.connector(a+1,0,a)
    
    for i,bitval in enumerate(range(b,a+1)):
        keygate_input_name=f&#34;lockingkeyinput[{bitval}]&#34;
        bit=self.bitkey[self.bits-i-1]
        self.module.lockingdata[&#34;inputs&#34;].append((keygate_input_name,bit))
    
    # print(self.key_outputs.keys())
    for output in self.key_outputs:
        gatetype=&#34;XOR&#34;
        output_data=self.key_outputs[output]
        if(output_data[&#39;bits&#39;]!=1):
            start=output_data[&#34;startbit&#34;]
            end=output_data[&#34;endbit&#34;]
            cal_output_i=lambda output,bit_i:f&#34;{output}[{bit_i}]&#34;
        else:
            start=end=1
            cal_output_i=lambda output,_:f&#34;{output}&#34;
        
        for bit_i in range(start,end+1):
            output_i=cal_output_i(output,bit_i)
            keygatecount=len(self.module.gates)
            wirecount=len(self.module.io[&#39;wires&#39;])

            # print(output_i,bit_i)


            # print(&#34;output  &#34;,output_i)
            pred_i=list(self.circuitgraph.predecessors(output_i))
            if(pred_i==[]):
                continue
            else:
                # print(&#34;HERE  &#34;,pred_i)
                pred_i=pred_i[0]

            connection_gate=f&#34;connection_gate_Sarlock_{output}_{bit_i}_{keygatecount}&#34;
            connection_wire=f&#34;connection_wire_Sarlock_{output}_{bit_i}_{wirecount}&#34;


            self.circuitgraph.remove_edge(pred_i, output_i)

            self.circuitgraph.add_node(connection_gate,type=&#34;gate&#34;,logic=gatetype)
            self.circuitgraph.add_node(connection_wire,type=&#34;wire&#34;,logic=connection_wire)
            
            self.circuitgraph.add_edge(pred_i, connection_wire)
            self.circuitgraph.add_edge(connection_wire, connection_gate)
            self.circuitgraph.add_edge(outQ, connection_gate)
            self.circuitgraph.add_edge(connection_gate, output_i)

            
            # pred_i, output_i
            Na=self.circuitgraph.nodes[pred_i]
            # Nb=self.circuitgraph.nodes[NodeB]
            # print(NodeA,Na)
            if(Na[&#39;type&#39;]==&#39;gate&#39;):
                self.module.gates[Na[&#39;logic&#39;]][pred_i][&#39;outputs&#39;]=connection_wire
            elif(&#39;DFF&#39; in Na[&#39;type&#39;].upper()):
                # print(&#34;here &#34;,Na,pred_i)
                # print(self.module.FF_tech[Na[&#39;type&#39;]][pred_i])
                self.module.FF_tech[Na[&#39;type&#39;]][pred_i][&#39;outputs&#39;]=connection_wire
                # print(self.module.FF_tech[Na[&#39;type&#39;]][pred_i])
            else:
                raise Exception(&#34;NOT A GATE WHYYYYYY???????????&#34;)
            

            self.module.io[&#39;wires&#39;][connection_wire]=utils.connector(1,0,0)

            if(gatetype not in self.module.gates.keys()):
                self.module.gates[gatetype]={}
                
            self.module.gates[gatetype][connection_gate]={&#34;inputs&#34;: [connection_wire,outQ] ,&#34;outputs&#34;: output_i}</code></pre>
</details>
</dd>
<dt id="src.Locking.PostSAT.PostSAT.set_key"><code class="name flex">
<span>def <span class="ident">set_key</span></span>(<span>self, bits: int = 128, inputs: list = None, outputs: list = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_key(self,bits:int=128,inputs:list=None,outputs:list=None):
    # self.input_count={i:self.module.io[&#39;inputs&#39;][i][&#39;bits&#39;] for i in self.module.io[&#39;inputs&#39;]}

    self.inputs={i:self.module.io[&#39;inputs&#39;][i] for i in self.module.io[&#39;inputs&#39;]}
    utils.remove_key(self.inputs,&#34;lockingkeyinput&#34;)
    utils.remove_key(self.inputs,self.module.io[&#34;Clock_pins&#34;])

    if(inputs==None):
        self.key_inputs,returned_bits=utils.rand_selection(self.inputs,&#39;bits&#39;,bits)
        bits=returned_bits
        self.key=utils.randKey(bits, seed=None)
    else:     
        # self.key_inputs=inputs
        self.key_inputs={i:self.module.io[&#39;inputs&#39;][i] for i in inputs}
        bits=len(self.key_inputs)
        self.key=utils.randKey(bits, seed=None)

    # self.keystart=len(self.module.bitkey)

    self.bits=bits
    self.intkey,self.bitkey=utils.randKey(bits)
    self.module.bitkey=self.bitkey+self.module.bitkey

    if(outputs==None):
        self.key_outputs={i:self.module.io[&#39;outputs&#39;][i] for i in self.module.io[&#39;outputs&#39;]}
    else:     
        # self.key_outputs=outputs
        self.key_outputs={i:self.module.io[&#39;outputs&#39;][i] for i in outputs}</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.Locking" href="index.html">src.Locking</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.Locking.PostSAT.gencc" href="#src.Locking.PostSAT.gencc">gencc</a></code></li>
<li><code><a title="src.Locking.PostSAT.gencc_AntiSAT" href="#src.Locking.PostSAT.gencc_AntiSAT">gencc_AntiSAT</a></code></li>
<li><code><a title="src.Locking.PostSAT.gencc_SarLock" href="#src.Locking.PostSAT.gencc_SarLock">gencc_SarLock</a></code></li>
<li><code><a title="src.Locking.PostSAT.hammingcc" href="#src.Locking.PostSAT.hammingcc">hammingcc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.Locking.PostSAT.PostSAT" href="#src.Locking.PostSAT.PostSAT">PostSAT</a></code></h4>
<ul class="">
<li><code><a title="src.Locking.PostSAT.PostSAT.AntiSAT" href="#src.Locking.PostSAT.PostSAT.AntiSAT">AntiSAT</a></code></li>
<li><code><a title="src.Locking.PostSAT.PostSAT.Sarlock" href="#src.Locking.PostSAT.PostSAT.Sarlock">Sarlock</a></code></li>
<li><code><a title="src.Locking.PostSAT.PostSAT.set_key" href="#src.Locking.PostSAT.PostSAT.set_key">set_key</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>